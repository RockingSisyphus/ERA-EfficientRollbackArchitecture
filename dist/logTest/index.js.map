{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/webpack/bootstrap","src://tavern_helper_template/webpack/runtime/compat get default export","src://tavern_helper_template/webpack/runtime/define property getters","src://tavern_helper_template/webpack/runtime/hasOwnProperty shorthand","src://tavern_helper_template/external var \"_\"","src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/ERA变量框架/utils/constants.ts","src://tavern_helper_template/external var \"Vue\"","src://tavern_helper_template/src/ERA变量框架/utils/era_data.ts","src://tavern_helper_template/src/ERA变量框架/utils/log.ts","src://tavern_helper_template/src/ERA变量框架/utils/data.ts","src://tavern_helper_template/src/logTest/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = _;","const __WEBPACK_NAMESPACE_OBJECT__ = z;","/**\n * @file ERA 变量框架 - 核心常量模块\n * @description\n * 该文件集中定义了整个 ERA 框架所使用的关键常量。\n * 这些常量主要用作在酒馆 `chat` 变量中存储和检索 ERA 核心数据的路径（键名）。\n *\n * **核心数据结构**:\n * ERA 的数据被分为两部分，存储在 `chat` 变量下：\n * 1. **元数据 (ERAMetaData)**: 包含框架自身运行所需的核心数据，如 `EditLogs` 和 `SelectedMks`。\n * 2. **状态数据 (stat_data)**: 包含所有由用户和 AI 管理的游戏/故事变量，如 `player`、`world_state` 等。\n *\n * 其结构大致如下：\n * ```json\n * {\n *   \"ERAMetaData\": {\n *     \"EditLogs\": { ... },\n *     \"SelectedMks\": [ ... ]\n *   },\n *   \"stat_data\": {\n *     \"player\": { \"hp\": 100, \"gold\": 50 },\n *     \"world_state\": { ... }\n *   }\n * }\n * ```\n * 将这些路径定义为常量，有助于：\n * 1. **避免硬编码**：减少因拼写错误导致的 bug。\n * 2. **提高可维护性**：如果未来需要调整数据结构，只需修改此文件即可。\n * 3. **增强代码可读性**：常量的名称清晰地表达了其所指向的数据的含义。\n */\n\n'use strict';\n\nimport { z } from 'zod';\n\n/**\n * @constant {z.ZodObject} SettingsSchema\n * @description\n * 定义了脚本设置的 Zod schema，包括类型和默认值。\n */\nexport const SettingsSchema = z.object({\n  在ai消息尾部生成特殊符号: z.boolean().default(true),\n  特殊符号值: z.string().default('<StatusPlaceHolderImpl/>'),\n  开启悬浮球: z.boolean().default(true),\n  开启黑夜模式: z.boolean().default(false),\n  强制重载功能: z.boolean().default(false),\n  强制重载消息数: z.number().default(2),\n  繁体转简体: z.boolean().default(false),\n  调试模式: z.boolean().default(false),\n});\n\n/**\n * @type {EraConfig}\n * @description ERA 框架的配置类型。\n */\nexport type EraConfig = z.infer<typeof SettingsSchema>;\n\n/**\n * @constant {object} CHAT_SCOPE\n * @description\n * 用于酒馆助手 `getVariables` 和 `replaceVariables` 系列函数的 `scope` 参数。\n * 它指定了操作的目标是当前**聊天（Chat）**级别的变量。\n * ERA 框架的所有核心数据和用户变量都存储在此作用域下。\n */\nexport const CHAT_SCOPE = { type: 'chat' as const };\n\n/**\n * @constant {string} META_DATA_PATH\n * @description 在 `chat` 变量中，存储 ERA 框架**元数据**的根对象的键名。\n */\nexport const META_DATA_PATH = 'ERAMetaData';\n\n/**\n * @constant {string} STAT_DATA_PATH\n * @description 在 `chat` 变量中，存储用户**状态数据**的根对象的键名。\n */\nexport const STAT_DATA_PATH = 'stat_data';\n\n/**\n * @constant {string} LOGS_PATH\n * @description\n * 在 `ERAMetaData` 对象中，存储**编辑日志（Edit Logs）**的对象的键名，即 `\"EditLogs\"`。\n * `EditLogs` 是一个以**消息密钥（MK）**为键，以该消息引发的变量变更记录数组为值的对象。\n * 这是实现“逆序回滚”功能的基础数据。\n *\n * @example\n * // chat.ERAMetaData.EditLogs 的一个条目\n * \"era_mk_1759246942209_jipmrj\": [\n *   { \"op\": \"insert\", \"path\": \"testData.inventory\", \"value_new\": { \"gold\": 100, \"slots\": [\"sword\", \"shield\"] } },\n *   { \"op\": \"update\", \"path\": \"player.hp\", \"value_old\": 90, \"value_new\": 100 }\n * ]\n */\nexport const LOGS_PATH = 'EditLogs';\n\n/**\n * @constant {string} SEL_PATH\n * @description\n * 在 `ERAMetaData` 对象中，存储**已选择消息密钥链（Selected Message Keys）**的数组的键名，即 `\"SelectedMks\"`。\n * `SelectedMks` 是一个稀疏数组，其**索引约等于消息 ID**，值是该楼层消息的 MK。\n * 这个数组是 ERA 框架的“脊梁”，是连接抽象变量状态与具体聊天历史的桥梁。\n * 框架通过比对 `SelectedMks` 与实际消息流中的 MK，来判断数据是否需要同步。\n *\n * @example\n * // chat.ERAMetaData.SelectedMks\n * [ , \"era_mk_greeting\", \"era_mk_abc123\", , \"era_mk_xyz789\"]\n */\nexport const SEL_PATH = 'SelectedMks';\n\n/**\n * @constant {string} ERA_DATA_TAG\n * @description\n * 用于在消息内容中包裹 ERA 元数据（如消息密钥 MK）的 XML 风格标签名。\n * e.g., `<era_data>{...}</era_data>`\n */\nexport const ERA_DATA_TAG = 'era_data';\n\n/**\n * @constant {RegExp} ERA_DATA_REGEX\n * @description\n * 用于从消息内容字符串中匹配和提取 `<era_data>` 块的正则表达式。\n * 这个常量被定义在这里，以避免 `message_key.ts` 和 `message_utils.ts` 之间的循环依赖。\n */\nexport const ERA_DATA_REGEX = new RegExp(`<${ERA_DATA_TAG}>({.*?})<\\\\/${ERA_DATA_TAG}>`);\n\n/**\n * @constant {object} ERA_API_EVENTS\n * @description\n * 定义了所有供外部脚本通过 `eventEmit` 调用的自定义 API 事件名称。\n * 使用这些常量可以避免在代码中使用硬编码的字符串。\n */\nexport const ERA_API_EVENTS = {\n  INSERT_BY_OBJECT: 'era:insertByObject',\n  UPDATE_BY_OBJECT: 'era:updateByObject',\n  INSERT_BY_PATH: 'era:insertByPath',\n  UPDATE_BY_PATH: 'era:updateByPath',\n  DELETE_BY_OBJECT: 'era:deleteByObject',\n  DELETE_BY_PATH: 'era:deleteByPath',\n  /** 获取当前最新的变量状态 */\n  GET_CURRENT_VARS: 'era:getCurrentVars',\n  /** 获取指定 MK 的历史变量快照 */\n  GET_SNAPSHOT_AT_MK: 'era:getSnapshotAtMk',\n  /** 获取两个 MK 之间的所有历史变量快照 */\n  GET_SNAPSHOTS_BETWEEN_MKS: 'era:getSnapshotsBetweenMks',\n  /** 获取指定 message_id 的历史变量快照 */\n  GET_SNAPSHOT_AT_MID: 'era:getSnapshotAtMId',\n  /** 获取两个 message_id 之间的所有历史变量快照 */\n  GET_SNAPSHOTS_BETWEEN_MIDS: 'era:getSnapshotsBetweenMIds',\n  /** 请求 ERA 重新广播最新的 `writeDone` 事件 */\n  REQUEST_WRITE_DONE: 'era:requestWriteDone',\n} as const;\n\n/**\n * @constant {object} ERA_EVENT_EMITTER\n * @description 定义了所有由 ERA 框架**向外发出**的事件。\n */\nexport const ERA_EVENT_EMITTER = {\n  /** 当变量写入完成时触发 */\n  WRITE_DONE: 'era:writeDone',\n  /** 当API执行写入时触发 */\n  API_WRITE: 'era:apiWrite',\n  /** 当变量查询准备好时触发，用于响应 GET_... 系列 API 事件 */\n  VARS_QUERY_RESULT: 'era:queryResult',\n} as const;\n\n/**\n * 描述在一次事件处理循环中，执行了哪些核心操作。\n * 这对于外部脚本理解状态变更的原因至关重要。\n */\nexport interface ActionsTaken {\n  /** 是否执行了 `rollbackByMk` 操作 */\n  rollback: boolean;\n  /** 是否执行了 `ApplyVarChange` 操作 */\n  apply: boolean;\n  /** 是否执行了 `resyncStateOnHistoryChange` 操作 */\n  resync: boolean;\n  /** 是否执行了 API 调用 */\n  apiWrite: boolean;\n  /** 是否因编辑消息而触发了重新同步 */\n  editedResync: boolean;\n  /** 是否因滑动消息而触发了变量回退 */\n  swipedRollback: boolean;\n}\n\n/**\n * `era:writeDone` 事件的负载对象结构。它提供了关于一次成功写入操作的完整上下文。\n */\nexport interface WriteDonePayload {\n  /**\n   * 本轮事件处理循环中，最后操作的消息的**消息密钥 (Message Key)**。\n   * 通常由 `ensureMkForLatestMessage` 在循环开始时确定。\n   */\n  mk: string;\n  /**\n   * 本轮事件处理循环中，最后操作的消息的**消息 ID**。\n   */\n  message_id: number;\n  /**\n   * 最后操作的消息是否由用户发送。\n   */\n  is_user: boolean;\n  /**\n   * 描述在本轮事件处理中，执行了哪些核心操作。\n   */\n  actions: ActionsTaken;\n  /**\n   * 事件处理完成**之后**，整个聊天会话的**已选择消息密钥链 (Selected Message Keys)** 的最新状态。\n   * 这是一个稀疏数组，其索引约等于消息 ID，值是对应楼层消息的 MK。\n   * 它代表了当前聊天记录的“主干”，是 ERA 判断同步状态的核心数据结构。\n   */\n  selectedMks: (string | null)[];\n  /**\n   * 事件处理完成**之后**，`chat` 变量中存储的**完整的编辑日志对象 (EditLogs)**。\n   * 这是一个以 MK 为键，以变更记录数组为值的对象。\n   */\n  editLogs: { [key: string]: any[] };\n  /**\n   * 事件处理完成**之后**，整个聊天会话的**状态数据 (`stat_data`)** 的最新状态。\n   * 这个版本**包含**所有内部使用的 `$meta` 字段。\n   */\n  stat: any;\n  /**\n   * 事件处理完成**之后**，一个**不包含**任何 `$meta` 字段的 `stat_data` 的深拷贝版本。\n   * 适用于需要纯净数据进行展示或进一步处理的场景。\n   */\n  statWithoutMeta: any;\n  /**\n   * 表示这是对当前 `mk` 的第几次连续处理。\n   * 如果一个新的 `mk` 被处理，这个计数会重置为 1。\n   * 这对于需要感知状态是否在同一消息上连续更新的外部脚本很有用。\n   */\n  consecutiveProcessingCount: number;\n}\n\n/**\n * `era:queryResult` 事件中，单个查询结果的结构。\n */\nexport interface QueryResultItem {\n  mk: string;\n  message_id: number;\n  is_user: boolean;\n  stat: any;\n  statWithoutMeta: any;\n}\n\n/**\n * `era:queryResult` 事件的负载对象结构。\n */\nexport interface QueryResultPayload {\n  /** 原始查询的类型 */\n  queryType:\n    | 'getCurrentVars'\n    | 'getSnapshotAtMk'\n    | 'getSnapshotsBetweenMks'\n    | 'getSnapshotAtMId'\n    | 'getSnapshotsBetweenMIds';\n  /** 原始查询的 detail 对象 */\n  request: any;\n  /** 查询的结果。根据 queryType，可以是单个结果或结果数组。 */\n  result: QueryResultItem | QueryResultItem[];\n  /**\n   * 查询执行时，整个聊天会话的**已选择消息密钥链 (Selected Message Keys)** 的最新状态。\n   */\n  selectedMks: (string | null)[];\n  /**\n   * 查询执行时，`chat` 变量中存储的**完整的编辑日志对象 (EditLogs)**。\n   */\n  editLogs: { [key: string]: any[] };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = Vue;","/**\n * @file ERA 变量框架 - ERA 核心变量读写模块\n */\n\n'use strict';\n\nimport _ from 'lodash';\nimport { CHAT_SCOPE, META_DATA_PATH, STAT_DATA_PATH, SettingsSchema, EraConfig } from './constants';\nimport { ref, readonly, DeepReadonly, Ref } from 'vue';\n\ndeclare function getScriptId(): string;\n\n// --- 响应式配置中心 ---\n\n/**\n * @description 存储全局脚本设置的响应式引用。\n * @internal\n */\nconst scriptSettingsRef: Ref<EraConfig> = ref(SettingsSchema.parse({}));\n\n/**\n * @description 供外部模块使用的只读的脚本设置。\n * @example\n * import { settings } from './utils/era_data';\n * if (settings.value.调试模式) { ... }\n */\nexport const settings: DeepReadonly<Ref<EraConfig>> = readonly(scriptSettingsRef);\n\n/**\n * @description 初始化脚本设置，从酒馆变量中读取并填充到响应式引用中。\n * 应在脚本启动时调用一次。\n */\nexport function initEraSettings() {\n  const rawSettings = getVariables({ type: 'script', script_id: getScriptId() });\n  scriptSettingsRef.value = SettingsSchema.parse(rawSettings ?? {});\n}\n\n/**\n * 递归地从对象中移除所有以 `$` 开头的字段（如 `$meta`, `$template`）。\n * 此函数会创建一个对象的深拷贝，因此不会修改原始对象。\n * @param {any} obj - 待处理的对象或值。\n * @returns {any} 一个不包含 `$` 前缀字段的新对象或原始值。\n */\nexport function removeMetaFields(obj: any): any {\n  // 对于非对象类型，直接返回原始值\n  if (!_.isObject(obj)) {\n    return obj;\n  }\n\n  // 创建深拷贝以避免修改原始对象\n  const newObj = _.cloneDeep(obj);\n\n  function recurse(current: any) {\n    if (Array.isArray(current)) {\n      // 如果是数组，则递归处理数组中的每个元素\n      current.forEach(item => recurse(item));\n    } else if (_.isPlainObject(current)) {\n      // 如果是纯粹的对象，遍历其所有键\n      for (const key in current) {\n        // 如果键以 '$' 开头，则删除该属性\n        if (key.startsWith('$')) {\n          delete current[key];\n        } else {\n          // 否则，递归处理该属性的值\n          recurse(current[key]);\n        }\n      }\n    }\n  }\n\n  recurse(newObj);\n  return newObj;\n}\n\n/**\n * 获取并确保 ERA 的元数据和状态数据对象的存在。\n * @returns {{meta: object, stat: object}} 包含元数据和状态数据的对象。\n */\nexport function getEraData(): { meta: any; stat: any } {\n  const chatVars = getVariables(CHAT_SCOPE) || {};\n  const meta = _.get(chatVars, META_DATA_PATH, {});\n  const stat = _.get(chatVars, STAT_DATA_PATH, {});\n  return { meta, stat };\n}\n\n/**\n * 原子性地更新 ERA 的状态数据 (stat_data)。\n * @param {(currentStatData: any) => (any | Promise<any>)} updater - 一个接收当前 stat_data 并返回修改后 stat_data 的函数 (可以是 async)。\n */\nexport async function updateEraStatData(updater: (currentStatData: any) => any | Promise<any>) {\n  await updateVariablesWith(async v => {\n    const currentStat = _.get(v, STAT_DATA_PATH, {});\n    const newStat = await updater(currentStat);\n    _.set(v, STAT_DATA_PATH, newStat);\n    return v;\n  }, CHAT_SCOPE);\n}\n\n/**\n * 原子性地更新 ERA 的元数据 (ERAMetaData)。\n * @param {(currentMetaData: any) => (any | Promise<any>)} updater - 一个接收当前 ERAMetaData 并返回修改后 ERAMetaData 的函数 (可以是 async)。\n */\nexport async function updateEraMetaData(updater: (currentMetaData: any) => any | Promise<any>) {\n  await updateVariablesWith(async v => {\n    const currentMeta = _.get(v, META_DATA_PATH, {});\n    const newMeta = await updater(currentMeta);\n    _.set(v, META_DATA_PATH, newMeta);\n    return v;\n  }, CHAT_SCOPE);\n}\n\n/**\n * 原子性地更新脚本设置\n * @param {(currentSettings: EraConfig) => EraConfig | Promise<EraConfig>} updater\n * @returns {Promise<void>}\n */\nexport async function updateScriptSettings(\n  updater: (currentSettings: EraConfig) => EraConfig | Promise<EraConfig>,\n): Promise<void> {\n  await updateVariablesWith(\n    async rawSettings => {\n      const currentSettings = SettingsSchema.parse(rawSettings ?? {});\n      const newSettings = await updater(currentSettings);\n      // 更新内存中的响应式引用\n      scriptSettingsRef.value = newSettings;\n      return newSettings;\n    },\n    { type: 'script', script_id: getScriptId() },\n  );\n}\n","/**\n * @file ERA 变量框架 - 日志记录模块 (V3 - 规则分离版)\n */\n\n'use strict';\n\nimport { settings } from './era_data';\n\n// --- 新的运行时调试配置系统 (V3) ---\n\n/**\n * @constant {string} DEBUG_CONFIG_LS_KEY\n * @description 用于在 localStorage 中存储调试配置的键名。\n */\nconst DEBUG_CONFIG_LS_KEY = 'era_debug_config';\n\nlet enabledPatterns: RegExp[] = [];\nlet disabledPatterns: RegExp[] = [];\n\n/**\n * @typedef {object} DebugConfig\n * @property {string[]} enabled - 启用的模式列表。\n * @property {string[]} disabled - 禁用的模式列表。\n */\n\n/**\n * 从 localStorage 加载并解析调试配置。\n */\nfunction loadDebugConfig() {\n  try {\n    const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n    /** @type {DebugConfig} */\n    const config = JSON.parse(configStr);\n\n    const toRegex = (p: string) => new RegExp(`^${p.replace(/\\*/g, '.*?')}$`);\n    enabledPatterns = (config.enabled || []).map(toRegex);\n    disabledPatterns = (config.disabled || []).map(toRegex);\n  } catch (e) {\n    console.error('《ERA-Log》: 加载调试配置失败。', e);\n    enabledPatterns = [];\n    disabledPatterns = [];\n  }\n}\n\n/**\n * 检查给定的模块名是否应该输出 debug 日志。\n * @param {string} moduleName - 要检查的模块名。\n * @returns {boolean} - 如果允许输出则返回 true。\n */\nfunction isDebugEnabled(moduleName: string): boolean {\n  if (!moduleName) return false;\n\n  // 规则 1: 如果匹配任何一个“禁用”模式，则绝对禁用。\n  if (disabledPatterns.some(re => re.test(moduleName))) {\n    return false;\n  }\n\n  // 规则 2: 如果“启用”列表为空，则全部禁用。\n  if (enabledPatterns.length === 0) {\n    return false;\n  }\n\n  // 规则 3: 如果匹配任何一个“启用”模式，则启用。\n  if (enabledPatterns.some(re => re.test(moduleName))) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * 更新并保存调试配置。\n * @param {{ enabled: string[], disabled: string[] }} newConfig\n */\nfunction updateConfig(newConfig: { enabled: string[]; disabled: string[] }) {\n  const uniqueConfig = {\n    enabled: [...new Set(newConfig.enabled)],\n    disabled: [...new Set(newConfig.disabled)],\n  };\n  globalThis.localStorage?.setItem(DEBUG_CONFIG_LS_KEY, JSON.stringify(uniqueConfig));\n  loadDebugConfig();\n  console.log(`%c《ERA-Log》调试模式已更新。`, 'color: #3498db; font-weight: bold;', {\n    '启用 (Enabled)': uniqueConfig.enabled,\n    '禁用 (Disabled)': uniqueConfig.disabled,\n  });\n}\n\n// 初始化配置\nloadDebugConfig();\n\n// 将控制对象暴露到全局\nif (typeof globalThis !== 'undefined') {\n  const eraDebug = {\n    /**\n     * 将一个模式添加到“启用列表”，使其匹配的模块显示日志。\n     * 这也会从“禁用列表”中移除该模式。\n     * @param {string} pattern - 要启用的模式，支持 * 通配符。\n     * @example\n     * // 开启所有 core 开头的模块\n     * eraDebug.add('core*')\n     */\n    add(pattern: string) {\n      const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n      const config: { enabled: string[]; disabled: string[] } = JSON.parse(configStr);\n      const enabled = new Set(config.enabled || []);\n      const disabled = new Set(config.disabled || []);\n\n      enabled.add(pattern);\n      disabled.delete(pattern);\n\n      updateConfig({ enabled: Array.from(enabled), disabled: Array.from(disabled) });\n    },\n\n    /**\n     * 将一个模式添加到“禁用列表”，使其匹配的模块不显示日志。\n     * 这也会从“启用列表”中移除该模式。\n     * @param {string} pattern - 要禁用的模式，支持 * 通配符。\n     * @example\n     * // 禁用 core-key 模块\n     * eraDebug.remove('core-key')\n     */\n    remove(pattern: string) {\n      const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n      const config: { enabled: string[]; disabled: string[] } = JSON.parse(configStr);\n      const enabled = new Set(config.enabled || []);\n      const disabled = new Set(config.disabled || []);\n\n      disabled.add(pattern);\n      enabled.delete(pattern);\n\n      updateConfig({ enabled: Array.from(enabled), disabled: Array.from(disabled) });\n    },\n\n    /**\n     * 查看当前的调试配置。\n     */\n    status() {\n      const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n      const config = JSON.parse(configStr);\n      console.log(`%c《ERA-Log》当前调试配置:`, 'color: #3498db; font-weight: bold;', config);\n    },\n\n    /**\n     * 清空所有调试规则。\n     */\n    clear() {\n      updateConfig({ enabled: [], disabled: [] });\n    },\n  };\n\n  (globalThis as any).eraDebug = eraDebug;\n}\n\n// --- Logger 类 ---\n\n/**\n * @class Logger\n * @description 一个为 ERA 框架设计的、支持动态配置的日志记录器。\n *\n * **核心功能**:\n * 1. **动态调试**: 可通过浏览器控制台 `eraDebug('...')` 命令在运行时开启/关闭指定模块的 `debug` 日志。\n * 2. **统一格式**: 所有日志都遵循 `《ERA》「模块名」【函数名】日志内容` 的格式。\n * 3. **自动模块名**: 自动从调用栈解析模块名，推荐在每个文件中创建独立的 logger 实例以保证准确性。\n *    例如: `const logger = new Logger();`\n */\nexport const logContext = {\n  mk: '',\n};\n\nexport class Logger {\n  private moduleName: string;\n\n  /**\n   * 创建一个新的 Logger 实例。\n   * @param moduleName - 【请勿手动填写】此参数由 Webpack 构建过程自动注入，用于标识当前模块。\n   */\n  constructor(moduleName?: string) {\n    // 优先使用由 Webpack 注入的模块名，如果不存在，则回退到旧的堆栈解析方法（仅用于非打包环境）\n    this.moduleName = moduleName || this._getModuleNameFromStack() || 'unknown';\n  }\n\n  private _getModuleNameFromStack(): string | null {\n    try {\n      const stack = new Error().stack || '';\n      // 智能寻找调用者：遍历堆栈，找到第一个不属于 log.ts 的、包含项目路径的行\n      const callerLine = stack\n        .split('\\n')\n        .find(\n          line =>\n            (line.includes(`/src/ERA变量框架/`) ||\n              line.includes(`/dist/ERA变量框架/`) ||\n              line.includes(`\\\\src\\\\ERA变量框架\\\\`) ||\n              line.includes(`\\\\dist\\\\ERA变量框架\\\\`)) &&\n            !line.includes('/utils/log.ts'),\n        );\n\n      if (!callerLine) {\n        return null;\n      }\n\n      // 更鲁棒的正则，用于从不同格式的堆栈行中提取路径\n      const match = callerLine.match(new RegExp(`(src|dist)[\\\\\\\\/]ERA变量框架[\\\\\\\\/]([^?:]+)`));\n\n      if (!match || !match[2]) {\n        return null;\n      }\n\n      const path = match[2];\n\n      // 移除文件扩展名和 /index 后缀，并统一路径分隔符\n      return path\n        .replace(/\\\\/g, '/')\n        .replace(/\\.(vue|ts|js)$/, '')\n        .replace(/\\/index$/, '');\n    } catch (e) {\n      console.error('《ERA-Log-Debug》: 解析模块名时发生意外错误。', e);\n      return null;\n    }\n  }\n\n  private formatMessage(funcName: string, message: any): string {\n    const mkString = logContext.mk ? `（${logContext.mk}）` : '';\n    return `《ERA》${mkString}「${this.moduleName}」【${funcName}】${String(message)}`;\n  }\n\n  debug(funcName: string, message: any, obj?: any) {\n    if (!isDebugEnabled(this.moduleName)) {\n      return;\n    }\n\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (obj !== undefined) {\n      console.debug(formattedMessage, obj);\n    } else {\n      console.debug(formattedMessage);\n    }\n  }\n\n  log(funcName: string, message: any, obj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (obj !== undefined) {\n      console.log(`%c${formattedMessage}`, 'color: #3498db;', obj);\n    } else {\n      console.log(`%c${formattedMessage}`, 'color: #3498db;');\n    }\n  }\n\n  warn(funcName: string, message: any, obj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (obj !== undefined) {\n      console.warn(`%c${formattedMessage}`, 'color: #f39c12;', obj);\n    } else {\n      console.warn(`%c${formattedMessage}`, 'color: #f39c12;');\n    }\n    if (settings.value.调试模式) {\n      toastr.warning(formattedMessage);\n    }\n  }\n\n  error(funcName: string, message: any, errorObj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (errorObj !== undefined) {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;', errorObj);\n    } else {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;');\n    }\n    if (settings.value.调试模式) {\n      toastr.error(formattedMessage);\n    }\n  }\n}\n","/**\n * @file ERA 变量框架 - 通用数据处理模块\n */\n\n'use strict';\n\nimport { Logger } from './log';\n\nconst logger = new Logger();\n\nconst ESCAPE_MAP: { [key: string]: string } = {\n  '.': '__DOT__',\n  '\"': '__DQUOTE__',\n  \"'\": '__SQUOTE__',\n};\n\nconst UNESCAPE_MAP: { [key: string]: string } = _.invert(ESCAPE_MAP);\n\nconst escapeRegex = new RegExp(Object.keys(ESCAPE_MAP).map(_.escapeRegExp).join('|'), 'g');\nconst unescapeRegex = new RegExp(Object.values(ESCAPE_MAP).map(_.escapeRegExp).join('|'), 'g');\n\n/**\n * 递归地转义对象或数组中所有字符串值和键的特殊字符。\n * @param data - 要处理的数据。\n * @returns - 转义后的数据。\n */\nexport function escapeEraData<T>(data: T): T {\n  if (Array.isArray(data)) {\n    return data.map(item => escapeEraData(item)) as any;\n  }\n  if (_.isPlainObject(data)) {\n    const newObj: { [key: string]: any } = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        const escapedKey = key.replace(escapeRegex, match => ESCAPE_MAP[match]);\n        newObj[escapedKey] = escapeEraData((data as any)[key]);\n      }\n    }\n    return newObj as any;\n  }\n  if (typeof data === 'string') {\n    return data.replace(escapeRegex, match => ESCAPE_MAP[match]) as any;\n  }\n  return data;\n}\n\n/**\n * 递归地反转义对象或数组中所有字符串值和键的特殊字符。\n * @param data - 要处理的数据。\n * @returns - 反转义后的数据。\n */\nexport function unescapeEraData<T>(data: T): T {\n  if (Array.isArray(data)) {\n    return data.map(item => unescapeEraData(item)) as any;\n  }\n  if (_.isPlainObject(data)) {\n    const newObj: { [key: string]: any } = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        const unescapedKey = key.replace(unescapeRegex, match => UNESCAPE_MAP[match]);\n        newObj[unescapedKey] = unescapeEraData((data as any)[key]);\n      }\n    }\n    return newObj as any;\n  }\n  if (typeof data === 'string') {\n    return data.replace(unescapeRegex, match => UNESCAPE_MAP[match]) as any;\n  }\n  return data;\n}\n\n/**\n * 判断一个值是否为“纯粹的对象”（Plain Object）。\n * 数组、null、函数、Date 对象等都会返回 false。\n * @param {*} v - 待检查的值。\n * @returns {boolean} 如果是纯粹的对象则返回 true，否则返回 false。\n */\nexport const isPO = (v: any): v is Record<string, any> => _.isPlainObject(v);\n\n/**\n * 递归地“净化”一个对象，将其中的数组或对象值转换为字符串。\n * 主要用于准备数据以便在某些特定场景下展示或存储。\n * @param {*} v - 待净化的值。\n * @returns {*} 净化后的值。\n */\nexport function sanitizeArrays(v: any): any {\n  if (Array.isArray(v)) {\n    // 如果是数组，则遍历其元素。如果元素是数组或对象，则字符串化它。\n    return v.map(e => (Array.isArray(e) || _.isPlainObject(e) ? JSON.stringify(e) : e));\n  } else if (_.isPlainObject(v)) {\n    // 如果是对象，则递归地对其每个属性值进行净化。\n    const o: { [key: string]: any } = {};\n    for (const k in v) o[k] = sanitizeArrays(v[k]);\n    return o;\n  } else {\n    // 其他类型的值直接返回。\n    return v;\n  }\n}\n\n/**\n * 安全地将一个对象序列化为格式化的 JSON 字符串。\n * 如果序列化失败，不会抛出异常，而是返回一个包含错误信息的字符串。\n * @param {*} o - 待序列化的对象。\n * @returns {string} 成功则返回 JSON 字符串，失败则返回错误提示。\n */\nexport const J = (o: any): string => {\n  try {\n    return JSON.stringify(o, null, 2); // 使用 2 个空格进行缩进，提高可读性。\n  } catch (e: any) {\n    return `<<stringify失败: ${e?.message || e}>>`;\n  }\n};\n\n/**\n * 使用“新数组覆盖旧数组”的策略来深度合并两个对象。\n * 这是 `_.merge` 的一个变体，专门用于处理模板合并等场景，\n * 在这些场景中，我们希望补丁对象中的数组能够完全替换基础对象中的数组，而不是合并它们。\n * @param {*} base - 基础对象。\n * @param {*} patch - 补丁对象。\n * @returns {*} 合并后的新对象。\n */\nexport function mergeReplaceArray(base: any, patch: any): any {\n  // 使用 _.cloneDeep 确保不修改原始对象。\n  return _.mergeWith(_.cloneDeep(base), _.cloneDeep(patch), (a: any, b: any) => {\n    // 自定义合并逻辑：如果任一值为数组，则直接返回补丁值（b），从而实现覆盖。\n    if (Array.isArray(a) || Array.isArray(b)) return b;\n    // 对于非数组类型，返回 undefined 以使用 _.merge 的默认合并行为。\n    return undefined;\n  });\n}\n\n/**\n * 健壮地解析 `EditLog` 的原始数据。\n * `EditLog` 可能以多种格式存在（对象、数组、JSON字符串），此函数旨在统一处理它们。\n * @param {*} raw - 从变量中读取的原始 `EditLog` 数据。\n * @returns {any[]} 解析后的 `EditLog` 数组。如果解析失败或输入无效，则返回一个空数组。\n */\nexport function parseEditLog(raw: any): any[] {\n  if (Array.isArray(raw)) return raw;\n  if (raw && typeof raw === 'object') return [raw]; // 单个对象也视为有效日志\n  if (typeof raw === 'string') {\n    const s = raw.replace(/^\\s*```(?:json)?\\s*|\\s*```\\s*$/g, ''); // 移除代码围栏\n    try {\n      const arr = JSON.parse(s);\n      return Array.isArray(arr) ? arr : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\n/**\n * 智能地从字符串中移除各种风格的注释，同时保留字符串字面量中的内容。\n *\n * **工作原理**:\n * 该函数通过一个小型状态机来逐字解析输入字符串。它维护一个 `inString` 状态，\n * 用于判断当前字符是否位于一个双引号包裹的字符串内部。\n *\n * 1. 当检测到进入或退出一个字符串时（通过非转义的双引号 `\"`），`inString` 状态会翻转。\n * 2. 如果 `inString` 为 `true`，则所有字符都会被无条件地保留。这确保了字符串值（如 URL）中的 `//` 或 `/*` 不会被当作注释处理。\n * 3. 如果 `inString` 为 `false`，函数会检查是否存在注释标记（`//`, `/*`, `<!--`）。\n * 4. 如果找到注释标记，函数会向前扫描直到注释结束，并跳过这部分内容。\n * 5. 如果没有找到注释，则将当前字符追加到结果中。\n *\n * @param str - 待处理的字符串。\n * @returns 移除了注释的字符串。\n */\nfunction stripComments(str: string): string {\n  if (!str) return '';\n\n  let result = '';\n  let inString = false; // 状态：是否在字符串内部\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n\n    // 检查是否进入或退出字符串。忽略转义的双引号 `\\\"`。\n    if (char === '\"' && (i === 0 || str[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，直接追加字符，不进行任何注释检查。\n    if (inString) {\n      result += char;\n      continue;\n    }\n\n    // --- 只有在字符串外部时，才进行注释检查 ---\n    const nextChar = str[i + 1];\n\n    // 检查行注释 `//`\n    if (char === '/' && nextChar === '/') {\n      const endOfLine = str.indexOf('\\n', i + 2);\n      if (endOfLine === -1) {\n        // 如果没有换行符，说明注释直到字符串末尾，直接结束循环。\n        break;\n      }\n      // 保留换行符，并将索引 `i` 快进到行尾。\n      result += '\\n';\n      i = endOfLine;\n      continue;\n    }\n\n    // 检查块注释 `/* ... */`\n    if (char === '/' && nextChar === '*') {\n      const endOfComment = str.indexOf('*/', i + 2);\n      if (endOfComment === -1) {\n        // 未闭合的注释，忽略剩余所有内容。\n        break;\n      }\n      // 将索引 `i` 快进到注释结尾。\n      i = endOfComment + 1;\n      continue;\n    }\n\n    // 检查 HTML 注释 `<!-- ... -->`\n    if (char === '<' && str.substring(i, i + 4) === '<!--') {\n      const endOfComment = str.indexOf('-->', i + 4);\n      if (endOfComment === -1) {\n        // 未闭合的注释。\n        break;\n      }\n      i = endOfComment + 2;\n      continue;\n    }\n\n    // 如果不是注释，则保留该字符。\n    result += char;\n  }\n  return result;\n}\n\n/**\n * 解析一个包含多个串联 JSON 对象的字符串（类似于 JSONL 格式）。\n * 这种格式有时会由 AI 生成。此函数能够逐个提取并解析它们。\n *\n * @param {string} str - 待解析的字符串。\n * @returns {any[]} 解析出的对象数组。\n */\nexport function parseJsonl(str: string): any[] {\n  const objects: any[] = [];\n  if (!str || typeof str !== 'string') {\n    return objects;\n  }\n\n  // 在解析 JSON 之前，必须先安全地移除所有注释。\n  // 不能使用简单的正则表达式（如 `/\\/\\/.*/g`），因为它无法区分代码中的注释和字符串值（如 URL \"https://...\"）中的 `//`，\n  // 会错误地破坏 JSON 字符串的结构。`stripComments` 函数通过状态管理解决了这个问题。\n  const strWithoutComments = stripComments(str);\n  const trimmedStr = strWithoutComments.trim();\n\n  let braceCount = 0; // 花括号平衡计数器\n  let startIndex = -1; // 当前 JSON 对象的起始索引\n  let inString = false; // 标记是否处于双引号字符串内部\n\n  for (let i = 0; i < trimmedStr.length; i++) {\n    const char = trimmedStr[i];\n\n    // 切换 inString 状态，忽略转义的双引号\n    if (char === '\"' && (i === 0 || trimmedStr[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，则跳过所有花括号的逻辑判断\n    if (inString) continue;\n\n    if (char === '{') {\n      if (braceCount === 0) {\n        // 发现一个新 JSON 对象的开始\n        startIndex = i;\n      }\n      braceCount++;\n    } else if (char === '}') {\n      if (braceCount > 0) {\n        braceCount--;\n        if (braceCount === 0 && startIndex !== -1) {\n          // 花括号平衡，一个完整的 JSON 对象被找到\n          const jsonString = trimmedStr.substring(startIndex, i + 1);\n          try {\n            const obj = JSON.parse(jsonString);\n            objects.push(obj);\n          } catch (e: any) {\n            // 如果解析失败，记录错误并继续，不中断整个过程\n            logger.error(`JSONL 解析失败: ${e?.message || e}. 失败的片段: ${jsonString}`, e);\n          }\n          // 重置状态，准备寻找下一个对象\n          startIndex = -1;\n        }\n      }\n    }\n  }\n  return objects;\n}\n","import { unescapeEraData } from '../ERA变量框架/utils/data';\nimport { getEraData, removeMetaFields } from '../ERA变量框架/utils/era_data';\nimport { Logger } from '../ERA变量框架/utils/log';\n\nconst logger = new Logger('LogTest-MacroParser');\n\n/**\n * 解析字符串中的 ERA 宏, 并将其替换为对应的变量值。\n * 这是提供给其他模块调用的公共接口。\n * @param text - 包含宏的输入字符串。\n * @param stat_data - 可选的，用于宏替换的特定变量快照。如果未提供，则使用最新的全局状态。\n * @returns - 替换宏后的字符串。\n */\nexport function parseEraMacros(text: string, statWithMeta?: object | null, statWithoutMeta?: object | null): string {\n  const macroRegex = /{{\\s*ERA(-withmeta)?\\s*:\\s*([^}]+?)\\s*}}/gi;\n\n  if (!text.includes('{{ERA')) {\n    return text;\n  }\n\n  // 如果没有提供特定的 stat，则从全局获取\n  const finalStatWithMeta = statWithMeta ?? getEraData().stat;\n  const finalStatWithoutMeta = statWithoutMeta ?? removeMetaFields(getEraData().stat);\n\n  return text.replace(macroRegex, (substring, withMeta, path) => {\n    const funcName = 'parseEraMacros';\n    const trimmedPath = path.trim();\n    const includeMeta = !!withMeta;\n\n    // 根据用户要求，选择正确的数据源\n    const statToUse = includeMeta ? finalStatWithMeta : finalStatWithoutMeta;\n\n    if (!statToUse) {\n      logger.warn(funcName, `无法获取到宏替换所需的数据 (includeMeta: ${includeMeta})`);\n      return substring; // 返回原始宏以避免破坏内容\n    }\n\n    let data;\n    if (trimmedPath === '$ALLDATA') {\n      data = statToUse;\n    } else {\n      data = _.get(statToUse, trimmedPath);\n    }\n\n    if (data === undefined) {\n      logger.warn(funcName, `在数据源中未找到路径 \"${trimmedPath}\", 宏将替换为空字符串.`);\n      return ''; // 路径未找到, 返回空字符串\n    }\n\n    // 因为我们已经从正确的数据源获取了数据，所以不再需要在这里手动移除 meta 字段\n    // 直接反转义即可\n    const finalData = unescapeEraData(data);\n\n    logger.debug(funcName, `宏替换数据反转义: ${trimmedPath}`, {\n      before: data,\n      after: finalData,\n    });\n\n    if (typeof finalData === 'object' && finalData !== null) {\n      return JSON.stringify(finalData);\n    }\n\n    return String(finalData);\n  });\n}\n\n/**\n * 在发送到 AI 的数据准备好后，处理其中的 ERA 宏。\n * @param generate_data - 包含提示词的对象。\n * @param dry_run - 是否为演习运行。\n */\nconst handleGenerateAfterData = (generate_data: { prompt: SillyTavern.SendingMessage[] }, dry_run: boolean) => {\n  if (dry_run) {\n    return;\n  }\n\n  // 检查提示中是否真的有宏，没有就直接返回，避免不必要的事件开销\n  const hasMacro = generate_data.prompt.some(p => typeof p.content === 'string' && p.content.includes('{{ERA'));\n\n  if (!hasMacro) {\n    return;\n  }\n\n  // 定义一次性事件处理器\n  const processMacros = (detail: any) => {\n    // 确保这是我们想要的查询结果\n    if (detail.queryType !== 'getCurrentVars') {\n      return;\n    }\n    // 移除监听器，避免内存泄漏和重复执行\n    eventRemoveListener('era:queryResult', processMacros);\n\n    // 检查错误\n    if (detail.result && detail.result.error) {\n      logger.error('handleGenerateAfterData', `ERA 查询 [getCurrentVars] 失败:`, detail.result.error);\n      return;\n    }\n\n    const statWithMeta = detail.result?.stat;\n    const statWithoutMeta = detail.result?.statWithoutMeta;\n\n    if (!statWithMeta || !statWithoutMeta) {\n      logger.warn('handleGenerateAfterData', `无法从 era:queryResult 事件中获取完整的变量快照，跳过宏替换。`);\n      return;\n    }\n\n    logger.debug('handleGenerateAfterData', '成功通过事件获取到当前变量快照，准备替换宏。');\n\n    // 使用快照替换所有消息中的宏\n    for (const message of generate_data.prompt) {\n      if (typeof message.content === 'string' && message.content.includes('{{ERA')) {\n        const originalContent = message.content;\n        // 将两个 stat 对象都传递给新的 parseEraMacros\n        message.content = parseEraMacros(originalContent, statWithMeta, statWithoutMeta);\n        if (originalContent !== message.content) {\n          logger.log('handleGenerateAfterData', `成功替换了 role: ${message.role} 消息中的 ERA 宏。`);\n        }\n      }\n    }\n  };\n\n  // 监听查询结果事件\n  //eventOn('era:queryResult', processMacros);\n\n  // 发送事件请求最新的变量状态\n  logger.debug('handleGenerateAfterData', '发送 era:getCurrentVars 事件以获取宏替换所需的状态。');\n  eventEmit('era:getCurrentVars');\n};\n\n$(() => {\n  console.log('日志测试脚本已加载。');\n\n  // 监听 `GENERATE_AFTER_DATA` 事件，在提示词发送前处理 ERA 宏\n  eventOn(tavern_events.GENERATE_AFTER_DATA, handleGenerateAfterData);\n\n  // 在卸载时清理监听器。\n  $(window).on('pagehide', () => {\n    eventRemoveListener(tavern_events.GENERATE_AFTER_DATA, handleGenerateAfterData);\n  });\n});\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","_","z","object","boolean","default","string","number","type","ERA_DATA_TAG","RegExp","Vue","scriptSettingsRef","ref","parse","settings","readonly","getEraData","chatVars","getVariables","meta","stat","DEBUG_CONFIG_LS_KEY","enabledPatterns","disabledPatterns","loadDebugConfig","configStr","globalThis","localStorage","getItem","config","JSON","toRegex","p","replace","enabled","map","disabled","e","console","error","updateConfig","newConfig","uniqueConfig","Set","setItem","stringify","log","eraDebug","add","pattern","delete","Array","from","remove","status","clear","logContext","Logger","moduleName","constructor","this","_getModuleNameFromStack","callerLine","Error","stack","split","find","line","includes","match","formatMessage","funcName","message","String","debug","some","re","test","length","formattedMessage","undefined","warn","value","toastr","warning","errorObj","ESCAPE_MAP","UNESCAPE_MAP","invert","unescapeRegex","keys","escapeRegExp","join","values","unescapeEraData","data","isArray","item","isPlainObject","newObj","parseEraMacros","text","statWithMeta","statWithoutMeta","finalStatWithMeta","finalStatWithoutMeta","recurse","current","forEach","startsWith","removeMetaFields","substring","withMeta","path","trimmedPath","trim","includeMeta","statToUse","finalData","before","after","handleGenerateAfterData","generate_data","dry_run","prompt","content","eventEmit","$","eventOn","tavern_events","GENERATE_AFTER_DATA","window","on","eventRemoveListener"],"sourceRoot":""}