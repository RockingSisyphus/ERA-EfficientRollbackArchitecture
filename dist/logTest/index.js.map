{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/ERA变量框架/utils/constants.ts","src://tavern_helper_template/external var \"Vue\"","src://tavern_helper_template/external var \"_\"","src://tavern_helper_template/src/ERA变量框架/utils/era_data.ts","src://tavern_helper_template/src/ERA变量框架/utils/log.ts","src://tavern_helper_template/src/ERA变量框架/utils/data.ts","src://tavern_helper_template/src/ERA变量框架/utils/string.ts","src://tavern_helper_template/src/ERA变量框架/utils/text.ts","src://tavern_helper_template/src/ERA变量框架/utils/message.ts","src://tavern_helper_template/src/logTest/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","/**\n * @file ERA 变量框架 - 核心常量模块\n * @description\n * 该文件集中定义了整个 ERA 框架所使用的关键常量。\n * 这些常量主要用作在酒馆 `chat` 变量中存储和检索 ERA 核心数据的路径（键名）。\n *\n * **核心数据结构**:\n * ERA 的数据被分为两部分，存储在 `chat` 变量下：\n * 1. **元数据 (ERAMetaData)**: 包含框架自身运行所需的核心数据，如 `EditLogs` 和 `SelectedMks`。\n * 2. **状态数据 (stat_data)**: 包含所有由用户和 AI 管理的游戏/故事变量，如 `player`、`world_state` 等。\n *\n * 其结构大致如下：\n * ```json\n * {\n *   \"ERAMetaData\": {\n *     \"EditLogs\": { ... },\n *     \"SelectedMks\": [ ... ]\n *   },\n *   \"stat_data\": {\n *     \"player\": { \"hp\": 100, \"gold\": 50 },\n *     \"world_state\": { ... }\n *   }\n * }\n * ```\n * 将这些路径定义为常量，有助于：\n * 1. **避免硬编码**：减少因拼写错误导致的 bug。\n * 2. **提高可维护性**：如果未来需要调整数据结构，只需修改此文件即可。\n * 3. **增强代码可读性**：常量的名称清晰地表达了其所指向的数据的含义。\n */\n\n'use strict';\n\nimport { z } from 'zod';\n\n/**\n * @constant {z.ZodObject} SettingsSchema\n * @description\n * 定义了脚本设置的 Zod schema，包括类型和默认值。\n */\nexport const SettingsSchema = z.object({\n  在ai消息尾部生成特殊符号: z.boolean().default(true),\n  特殊符号值: z.string().default('<StatusPlaceHolderImpl/>'),\n  开启悬浮球: z.boolean().default(true),\n  开启黑夜模式: z.boolean().default(false),\n  强制重载功能: z.boolean().default(false),\n  强制重载消息数: z.number().default(2),\n  繁体转简体: z.boolean().default(false),\n  调试模式: z.boolean().default(false),\n});\n\n/**\n * @type {EraConfig}\n * @description ERA 框架的配置类型。\n */\nexport type EraConfig = z.infer<typeof SettingsSchema>;\n\n/**\n * @constant {object} CHAT_SCOPE\n * @description\n * 用于酒馆助手 `getVariables` 和 `replaceVariables` 系列函数的 `scope` 参数。\n * 它指定了操作的目标是当前**聊天（Chat）**级别的变量。\n * ERA 框架的所有核心数据和用户变量都存储在此作用域下。\n */\nexport const CHAT_SCOPE = { type: 'chat' as const };\n\n/**\n * @constant {string} META_DATA_PATH\n * @description 在 `chat` 变量中，存储 ERA 框架**元数据**的根对象的键名。\n */\nexport const META_DATA_PATH = 'ERAMetaData';\n\n/**\n * @constant {string} STAT_DATA_PATH\n * @description 在 `chat` 变量中，存储用户**状态数据**的根对象的键名。\n */\nexport const STAT_DATA_PATH = 'stat_data';\n\n/**\n * @constant {string} LOGS_PATH\n * @description\n * 在 `ERAMetaData` 对象中，存储**编辑日志（Edit Logs）**的对象的键名，即 `\"EditLogs\"`。\n * `EditLogs` 是一个以**消息密钥（MK）**为键，以该消息引发的变量变更记录数组为值的对象。\n * 这是实现“逆序回滚”功能的基础数据。\n *\n * @example\n * // chat.ERAMetaData.EditLogs 的一个条目\n * \"era_mk_1759246942209_jipmrj\": [\n *   { \"op\": \"insert\", \"path\": \"testData.inventory\", \"value_new\": { \"gold\": 100, \"slots\": [\"sword\", \"shield\"] } },\n *   { \"op\": \"update\", \"path\": \"player.hp\", \"value_old\": 90, \"value_new\": 100 }\n * ]\n */\nexport const LOGS_PATH = 'EditLogs';\n\n/**\n * @constant {string} SEL_PATH\n * @description\n * 在 `ERAMetaData` 对象中，存储**已选择消息密钥链（Selected Message Keys）**的数组的键名，即 `\"SelectedMks\"`。\n * `SelectedMks` 是一个稀疏数组，其**索引约等于消息 ID**，值是该楼层消息的 MK。\n * 这个数组是 ERA 框架的“脊梁”，是连接抽象变量状态与具体聊天历史的桥梁。\n * 框架通过比对 `SelectedMks` 与实际消息流中的 MK，来判断数据是否需要同步。\n *\n * @example\n * // chat.ERAMetaData.SelectedMks\n * [ , \"era_mk_greeting\", \"era_mk_abc123\", , \"era_mk_xyz789\"]\n */\nexport const SEL_PATH = 'SelectedMks';\n\n/**\n * @constant {string} ERA_DATA_TAG\n * @description\n * 用于在消息内容中包裹 ERA 元数据（如消息密钥 MK）的 XML 风格标签名。\n * e.g., `<era_data>{...}</era_data>`\n */\nexport const ERA_DATA_TAG = 'era_data';\n\n/**\n * @constant {RegExp} ERA_DATA_REGEX\n * @description\n * 用于从消息内容字符串中匹配和提取 `<era_data>` 块的正则表达式。\n * 这个常量被定义在这里，以避免 `message_key.ts` 和 `message_utils.ts` 之间的循环依赖。\n */\nexport const ERA_DATA_REGEX = new RegExp(`<${ERA_DATA_TAG}>({.*?})<\\\\/${ERA_DATA_TAG}>`);\n\n/**\n * @constant {object} ERA_API_EVENTS\n * @description\n * 定义了所有供外部脚本通过 `eventEmit` 调用的自定义 API 事件名称。\n * 使用这些常量可以避免在代码中使用硬编码的字符串。\n */\nexport const ERA_API_EVENTS = {\n  INSERT_BY_OBJECT: 'era:insertByObject',\n  UPDATE_BY_OBJECT: 'era:updateByObject',\n  INSERT_BY_PATH: 'era:insertByPath',\n  UPDATE_BY_PATH: 'era:updateByPath',\n  DELETE_BY_OBJECT: 'era:deleteByObject',\n  DELETE_BY_PATH: 'era:deleteByPath',\n  /** 获取当前最新的变量状态 */\n  GET_CURRENT_VARS: 'era:getCurrentVars',\n  /** 获取指定 MK 的历史变量快照 */\n  GET_SNAPSHOT_AT_MK: 'era:getSnapshotAtMk',\n  /** 获取两个 MK 之间的所有历史变量快照 */\n  GET_SNAPSHOTS_BETWEEN_MKS: 'era:getSnapshotsBetweenMks',\n  /** 获取指定 message_id 的历史变量快照 */\n  GET_SNAPSHOT_AT_MID: 'era:getSnapshotAtMId',\n  /** 获取两个 message_id 之间的所有历史变量快照 */\n  GET_SNAPSHOTS_BETWEEN_MIDS: 'era:getSnapshotsBetweenMIds',\n  /** 请求 ERA 重新广播最新的 `writeDone` 事件 */\n  REQUEST_WRITE_DONE: 'era:requestWriteDone',\n} as const;\n\n/**\n * @constant {object} ERA_EVENT_EMITTER\n * @description 定义了所有由 ERA 框架**向外发出**的事件。\n */\nexport const ERA_EVENT_EMITTER = {\n  /** 当变量写入完成时触发 */\n  WRITE_DONE: 'era:writeDone',\n  /** 当API执行写入时触发 */\n  API_WRITE: 'era:apiWrite',\n  /** 当变量查询准备好时触发，用于响应 GET_... 系列 API 事件 */\n  VARS_QUERY_RESULT: 'era:queryResult',\n} as const;\n\n/**\n * 描述在一次事件处理循环中，执行了哪些核心操作。\n * 这对于外部脚本理解状态变更的原因至关重要。\n */\nexport interface ActionsTaken {\n  /** 是否执行了 `rollbackByMk` 操作 */\n  rollback: boolean;\n  /** 是否执行了 `ApplyVarChange` 操作 */\n  apply: boolean;\n  /** 是否执行了 `resyncStateOnHistoryChange` 操作 */\n  resync: boolean;\n  /** 是否执行了 API 调用 */\n  api: boolean;\n  /** 是否是由API调用触发的后续逻辑 */\n  apiWrite: boolean;\n  /** 是否因编辑消息而触发了重新同步 */\n  editedResync: boolean;\n  /** 是否因滑动消息而触发了变量回退 */\n  swipedRollback: boolean;\n}\n\n/**\n * `era:writeDone` 事件的负载对象结构。它提供了关于一次成功写入操作的完整上下文。\n */\nexport interface WriteDonePayload {\n  /**\n   * 本轮事件处理循环中，最后操作的消息的**消息密钥 (Message Key)**。\n   * 通常由 `ensureMkForLatestMessage` 在循环开始时确定。\n   */\n  mk: string;\n  /**\n   * 本轮事件处理循环中，最后操作的消息的**消息 ID**。\n   */\n  message_id: number;\n  /**\n   * 最后操作的消息是否由用户发送。\n   */\n  is_user: boolean;\n  /**\n   * 描述在本轮事件处理中，执行了哪些核心操作。\n   */\n  actions: ActionsTaken;\n  /**\n   * 事件处理完成**之后**，整个聊天会话的**已选择消息密钥链 (Selected Message Keys)** 的最新状态。\n   * 这是一个稀疏数组，其索引约等于消息 ID，值是对应楼层消息的 MK。\n   * 它代表了当前聊天记录的“主干”，是 ERA 判断同步状态的核心数据结构。\n   */\n  selectedMks: (string | null)[];\n  /**\n   * 事件处理完成**之后**，`chat` 变量中存储的**完整的编辑日志对象 (EditLogs)**。\n   * 这是一个以 MK 为键，以变更记录数组为值的对象。\n   */\n  editLogs: { [key: string]: any[] };\n  /**\n   * 事件处理完成**之后**，整个聊天会话的**状态数据 (`stat_data`)** 的最新状态。\n   * 这个版本**包含**所有内部使用的 `$meta` 字段。\n   */\n  stat: any;\n  /**\n   * 事件处理完成**之后**，一个**不包含**任何 `$meta` 字段的 `stat_data` 的深拷贝版本。\n   * 适用于需要纯净数据进行展示或进一步处理的场景。\n   */\n  statWithoutMeta: any;\n  /**\n   * 表示这是对当前 `mk` 的第几次连续处理。\n   * 如果一个新的 `mk` 被处理，这个计数会重置为 1。\n   * 这对于需要感知状态是否在同一消息上连续更新的外部脚本很有用。\n   */\n  consecutiveProcessingCount: number;\n}\n\n/**\n * `era:queryResult` 事件中，单个查询结果的结构。\n */\nexport interface QueryResultItem {\n  mk: string;\n  message_id: number;\n  is_user: boolean;\n  stat: any;\n  statWithoutMeta: any;\n}\n\n/**\n * `era:queryResult` 事件的负载对象结构。\n */\nexport interface QueryResultPayload {\n  /** 原始查询的类型 */\n  queryType:\n    | 'getCurrentVars'\n    | 'getSnapshotAtMk'\n    | 'getSnapshotsBetweenMks'\n    | 'getSnapshotAtMId'\n    | 'getSnapshotsBetweenMIds';\n  /** 原始查询的 detail 对象 */\n  request: any;\n  /** 查询的结果。根据 queryType，可以是单个结果或结果数组。 */\n  result: QueryResultItem | QueryResultItem[];\n  /**\n   * 查询执行时，整个聊天会话的**已选择消息密钥链 (Selected Message Keys)** 的最新状态。\n   */\n  selectedMks: (string | null)[];\n  /**\n   * 查询执行时，`chat` 变量中存储的**完整的编辑日志对象 (EditLogs)**。\n   */\n  editLogs: { [key: string]: any[] };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = Vue;","const __WEBPACK_NAMESPACE_OBJECT__ = _;","/**\n * @file ERA 变量框架 - ERA 核心变量读写模块\n */\n\n'use strict';\n\nimport _ from 'lodash';\nimport { CHAT_SCOPE, META_DATA_PATH, STAT_DATA_PATH, SettingsSchema, EraConfig } from './constants';\nimport { ref, readonly, DeepReadonly, Ref } from 'vue';\n\ndeclare function getScriptId(): string;\n\n// --- 响应式配置中心 ---\n\n/**\n * @description 存储全局脚本设置的响应式引用。\n * @internal\n */\nconst scriptSettingsRef: Ref<EraConfig> = ref(SettingsSchema.parse({}));\n\n/**\n * @description 供外部模块使用的只读的脚本设置。\n * @example\n * import { settings } from './utils/era_data';\n * if (settings.value.调试模式) { ... }\n */\nexport const settings: DeepReadonly<Ref<EraConfig>> = readonly(scriptSettingsRef);\n\n/**\n * @description 初始化脚本设置，从酒馆变量中读取并填充到响应式引用中。\n * 应在脚本启动时调用一次。\n */\nexport function initEraSettings() {\n  const rawSettings = getVariables({ type: 'script', script_id: getScriptId() });\n  scriptSettingsRef.value = SettingsSchema.parse(rawSettings ?? {});\n}\n\n/**\n * 递归地从对象中移除所有以 `$` 开头的字段（如 `$meta`, `$template`）。\n * 此函数会创建一个对象的深拷贝，因此不会修改原始对象。\n * @param {any} obj - 待处理的对象或值。\n * @returns {any} 一个不包含 `$` 前缀字段的新对象或原始值。\n */\nexport function removeMetaFields(obj: any): any {\n  // 对于非对象类型，直接返回原始值\n  if (!_.isObject(obj)) {\n    return obj;\n  }\n\n  // 创建深拷贝以避免修改原始对象\n  const newObj = _.cloneDeep(obj);\n\n  function recurse(current: any) {\n    if (Array.isArray(current)) {\n      // 如果是数组，则递归处理数组中的每个元素\n      current.forEach(item => recurse(item));\n    } else if (_.isPlainObject(current)) {\n      // 如果是纯粹的对象，遍历其所有键\n      for (const key in current) {\n        // 如果键以 '$' 开头，则删除该属性\n        if (key.startsWith('$')) {\n          delete current[key];\n        } else {\n          // 否则，递归处理该属性的值\n          recurse(current[key]);\n        }\n      }\n    }\n  }\n\n  recurse(newObj);\n  return newObj;\n}\n\n/**\n * 获取并确保 ERA 的元数据和状态数据对象的存在。\n * @returns {{meta: object, stat: object}} 包含元数据和状态数据的对象。\n */\nexport function getEraData(): { meta: any; stat: any } {\n  const chatVars = getVariables(CHAT_SCOPE) || {};\n  const meta = _.get(chatVars, META_DATA_PATH, {});\n  const stat = _.get(chatVars, STAT_DATA_PATH, {});\n  return { meta, stat };\n}\n\n/**\n * 原子性地更新 ERA 的状态数据 (stat_data)。\n * @param {(currentStatData: any) => (any | Promise<any>)} updater - 一个接收当前 stat_data 并返回修改后 stat_data 的函数 (可以是 async)。\n */\nexport async function updateEraStatData(updater: (currentStatData: any) => any | Promise<any>) {\n  await updateVariablesWith(async v => {\n    const currentStat = _.get(v, STAT_DATA_PATH, {});\n    const newStat = await updater(currentStat);\n    _.set(v, STAT_DATA_PATH, newStat);\n    return v;\n  }, CHAT_SCOPE);\n}\n\n/**\n * 原子性地更新 ERA 的元数据 (ERAMetaData)。\n * @param {(currentMetaData: any) => (any | Promise<any>)} updater - 一个接收当前 ERAMetaData 并返回修改后 ERAMetaData 的函数 (可以是 async)。\n */\nexport async function updateEraMetaData(updater: (currentMetaData: any) => any | Promise<any>) {\n  await updateVariablesWith(async v => {\n    const currentMeta = _.get(v, META_DATA_PATH, {});\n    const newMeta = await updater(currentMeta);\n    _.set(v, META_DATA_PATH, newMeta);\n    return v;\n  }, CHAT_SCOPE);\n}\n\n/**\n * 原子性地更新脚本设置\n * @param {(currentSettings: EraConfig) => EraConfig | Promise<EraConfig>} updater\n * @returns {Promise<void>}\n */\nexport async function updateScriptSettings(\n  updater: (currentSettings: EraConfig) => EraConfig | Promise<EraConfig>,\n): Promise<void> {\n  await updateVariablesWith(\n    async rawSettings => {\n      const currentSettings = SettingsSchema.parse(rawSettings ?? {});\n      const newSettings = await updater(currentSettings);\n      // 更新内存中的响应式引用\n      scriptSettingsRef.value = newSettings;\n      return newSettings;\n    },\n    { type: 'script', script_id: getScriptId() },\n  );\n}\n","/**\n * @file ERA 变量框架 - 日志记录模块 (V3 - 规则分离版)\n */\n\n'use strict';\n\nimport { settings } from './era_data';\n\n// --- 新的运行时调试配置系统 (V3) ---\n\n/**\n * @constant {string} DEBUG_CONFIG_LS_KEY\n * @description 用于在 localStorage 中存储调试配置的键名。\n */\nconst DEBUG_CONFIG_LS_KEY = 'era_debug_config';\n\nlet enabledPatterns: RegExp[] = [];\nlet disabledPatterns: RegExp[] = [];\n\n/**\n * @typedef {object} DebugConfig\n * @property {string[]} enabled - 启用的模式列表。\n * @property {string[]} disabled - 禁用的模式列表。\n */\n\n/**\n * 从 localStorage 加载并解析调试配置。\n */\nfunction loadDebugConfig() {\n  try {\n    const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n    /** @type {DebugConfig} */\n    const config = JSON.parse(configStr);\n\n    const toRegex = (p: string) => new RegExp(`^${p.replace(/\\*/g, '.*?')}$`);\n    enabledPatterns = (config.enabled || []).map(toRegex);\n    disabledPatterns = (config.disabled || []).map(toRegex);\n  } catch (e) {\n    console.error('《ERA-Log》: 加载调试配置失败。', e);\n    enabledPatterns = [];\n    disabledPatterns = [];\n  }\n}\n\n/**\n * 检查给定的模块名是否应该输出 debug 日志。\n * @param {string} moduleName - 要检查的模块名。\n * @returns {boolean} - 如果允许输出则返回 true。\n */\nfunction isDebugEnabled(moduleName: string): boolean {\n  if (!moduleName) return false;\n\n  // 规则 1: 如果匹配任何一个“禁用”模式，则绝对禁用。\n  if (disabledPatterns.some(re => re.test(moduleName))) {\n    return false;\n  }\n\n  // 规则 2: 如果“启用”列表为空，则全部禁用。\n  if (enabledPatterns.length === 0) {\n    return false;\n  }\n\n  // 规则 3: 如果匹配任何一个“启用”模式，则启用。\n  if (enabledPatterns.some(re => re.test(moduleName))) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * 更新并保存调试配置。\n * @param {{ enabled: string[], disabled: string[] }} newConfig\n */\nfunction updateConfig(newConfig: { enabled: string[]; disabled: string[] }) {\n  const uniqueConfig = {\n    enabled: [...new Set(newConfig.enabled)],\n    disabled: [...new Set(newConfig.disabled)],\n  };\n  globalThis.localStorage?.setItem(DEBUG_CONFIG_LS_KEY, JSON.stringify(uniqueConfig));\n  loadDebugConfig();\n  console.log(`%c《ERA-Log》调试模式已更新。`, 'color: #3498db; font-weight: bold;', {\n    '启用 (Enabled)': uniqueConfig.enabled,\n    '禁用 (Disabled)': uniqueConfig.disabled,\n  });\n}\n\n// 初始化配置\nloadDebugConfig();\n\n// 将控制对象暴露到全局\nif (typeof globalThis !== 'undefined') {\n  const eraDebug = {\n    /**\n     * 将一个模式添加到“启用列表”，使其匹配的模块显示日志。\n     * 这也会从“禁用列表”中移除该模式。\n     * @param {string} pattern - 要启用的模式，支持 * 通配符。\n     * @example\n     * // 开启所有 core 开头的模块\n     * eraDebug.add('core*')\n     */\n    add(pattern: string) {\n      const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n      const config: { enabled: string[]; disabled: string[] } = JSON.parse(configStr);\n      const enabled = new Set(config.enabled || []);\n      const disabled = new Set(config.disabled || []);\n\n      enabled.add(pattern);\n      disabled.delete(pattern);\n\n      updateConfig({ enabled: Array.from(enabled), disabled: Array.from(disabled) });\n    },\n\n    /**\n     * 将一个模式添加到“禁用列表”，使其匹配的模块不显示日志。\n     * 这也会从“启用列表”中移除该模式。\n     * @param {string} pattern - 要禁用的模式，支持 * 通配符。\n     * @example\n     * // 禁用 core-key 模块\n     * eraDebug.remove('core-key')\n     */\n    remove(pattern: string) {\n      const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n      const config: { enabled: string[]; disabled: string[] } = JSON.parse(configStr);\n      const enabled = new Set(config.enabled || []);\n      const disabled = new Set(config.disabled || []);\n\n      disabled.add(pattern);\n      enabled.delete(pattern);\n\n      updateConfig({ enabled: Array.from(enabled), disabled: Array.from(disabled) });\n    },\n\n    /**\n     * 查看当前的调试配置。\n     */\n    status() {\n      const configStr = globalThis.localStorage?.getItem(DEBUG_CONFIG_LS_KEY) || '{\"enabled\":[],\"disabled\":[]}';\n      const config = JSON.parse(configStr);\n      console.log(`%c《ERA-Log》当前调试配置:`, 'color: #3498db; font-weight: bold;', config);\n    },\n\n    /**\n     * 清空所有调试规则。\n     */\n    clear() {\n      updateConfig({ enabled: [], disabled: [] });\n    },\n  };\n\n  (globalThis as any).eraDebug = eraDebug;\n}\n\n// --- Logger 类 ---\n\n/**\n * @class Logger\n * @description 一个为 ERA 框架设计的、支持动态配置的日志记录器。\n *\n * **核心功能**:\n * 1. **动态调试**: 可通过浏览器控制台 `eraDebug('...')` 命令在运行时开启/关闭指定模块的 `debug` 日志。\n * 2. **统一格式**: 所有日志都遵循 `《ERA》「模块名」【函数名】日志内容` 的格式。\n * 3. **自动模块名**: 自动从调用栈解析模块名，推荐在每个文件中创建独立的 logger 实例以保证准确性。\n *    例如: `const logger = new Logger();`\n */\nexport const logContext = {\n  mk: '',\n};\n\nexport class Logger {\n  private moduleName: string;\n\n  /**\n   * 创建一个新的 Logger 实例。\n   * @param moduleName - 【请勿手动填写】此参数由 Webpack 构建过程自动注入，用于标识当前模块。\n   */\n  constructor(moduleName?: string) {\n    // 优先使用由 Webpack 注入的模块名，如果不存在，则回退到旧的堆栈解析方法（仅用于非打包环境）\n    this.moduleName = moduleName || this._getModuleNameFromStack() || 'unknown';\n  }\n\n  private _getModuleNameFromStack(): string | null {\n    try {\n      const stack = new Error().stack || '';\n      // 智能寻找调用者：遍历堆栈，找到第一个不属于 log.ts 的、包含项目路径的行\n      const callerLine = stack\n        .split('\\n')\n        .find(\n          line =>\n            (line.includes(`/src/ERA变量框架/`) ||\n              line.includes(`/dist/ERA变量框架/`) ||\n              line.includes(`\\\\src\\\\ERA变量框架\\\\`) ||\n              line.includes(`\\\\dist\\\\ERA变量框架\\\\`)) &&\n            !line.includes('/utils/log.ts'),\n        );\n\n      if (!callerLine) {\n        return null;\n      }\n\n      // 更鲁棒的正则，用于从不同格式的堆栈行中提取路径\n      const match = callerLine.match(new RegExp(`(src|dist)[\\\\\\\\/]ERA变量框架[\\\\\\\\/]([^?:]+)`));\n\n      if (!match || !match[2]) {\n        return null;\n      }\n\n      const path = match[2];\n\n      // 移除文件扩展名和 /index 后缀，并统一路径分隔符\n      return path\n        .replace(/\\\\/g, '/')\n        .replace(/\\.(vue|ts|js)$/, '')\n        .replace(/\\/index$/, '');\n    } catch (e) {\n      console.error('《ERA-Log-Debug》: 解析模块名时发生意外错误。', e);\n      return null;\n    }\n  }\n\n  private formatMessage(funcName: string, message: any): string {\n    const mkString = logContext.mk ? `（${logContext.mk}）` : '';\n    return `《ERA》${mkString}「${this.moduleName}」【${funcName}】${String(message)}`;\n  }\n\n  debug(funcName: string, message: any, obj?: any) {\n    if (!isDebugEnabled(this.moduleName)) {\n      return;\n    }\n\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (obj !== undefined) {\n      console.debug(formattedMessage, obj);\n    } else {\n      console.debug(formattedMessage);\n    }\n  }\n\n  log(funcName: string, message: any, obj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (obj !== undefined) {\n      console.log(`%c${formattedMessage}`, 'color: #3498db;', obj);\n    } else {\n      console.log(`%c${formattedMessage}`, 'color: #3498db;');\n    }\n  }\n\n  warn(funcName: string, message: any, obj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (obj !== undefined) {\n      console.warn(`%c${formattedMessage}`, 'color: #f39c12;', obj);\n    } else {\n      console.warn(`%c${formattedMessage}`, 'color: #f39c12;');\n    }\n    if (settings.value.调试模式) {\n      toastr.warning(formattedMessage);\n    }\n  }\n\n  error(funcName: string, message: any, errorObj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (errorObj !== undefined) {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;', errorObj);\n    } else {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;');\n    }\n    if (settings.value.调试模式) {\n      toastr.error(formattedMessage);\n    }\n  }\n}\n","/**\n * @file ERA 变量框架 - 通用数据处理模块\n */\n\n'use strict';\n\nimport { Logger } from './log';\n\nconst logger = new Logger();\n\nconst ESCAPE_MAP: { [key: string]: string } = {\n  '.': '__DOT__',\n  '\"': '__DQUOTE__',\n  \"'\": '__SQUOTE__',\n};\n\nconst UNESCAPE_MAP: { [key: string]: string } = _.invert(ESCAPE_MAP);\n\nconst escapeRegex = new RegExp(Object.keys(ESCAPE_MAP).map(_.escapeRegExp).join('|'), 'g');\nconst unescapeRegex = new RegExp(Object.values(ESCAPE_MAP).map(_.escapeRegExp).join('|'), 'g');\n\n/**\n * 递归地转义对象或数组中所有字符串值和键的特殊字符。\n * @param data - 要处理的数据。\n * @returns - 转义后的数据。\n */\nexport function escapeEraData<T>(data: T): T {\n  if (Array.isArray(data)) {\n    return data.map(item => escapeEraData(item)) as any;\n  }\n  if (_.isPlainObject(data)) {\n    const newObj: { [key: string]: any } = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        const escapedKey = key.replace(escapeRegex, match => ESCAPE_MAP[match]);\n        newObj[escapedKey] = escapeEraData((data as any)[key]);\n      }\n    }\n    return newObj as any;\n  }\n  if (typeof data === 'string') {\n    return data.replace(escapeRegex, match => ESCAPE_MAP[match]) as any;\n  }\n  return data;\n}\n\n/**\n * 递归地反转义对象或数组中所有字符串值和键的特殊字符。\n * @param data - 要处理的数据。\n * @returns - 反转义后的数据。\n */\nexport function unescapeEraData<T>(data: T): T {\n  if (Array.isArray(data)) {\n    return data.map(item => unescapeEraData(item)) as any;\n  }\n  if (_.isPlainObject(data)) {\n    const newObj: { [key: string]: any } = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        const unescapedKey = key.replace(unescapeRegex, match => UNESCAPE_MAP[match]);\n        newObj[unescapedKey] = unescapeEraData((data as any)[key]);\n      }\n    }\n    return newObj as any;\n  }\n  if (typeof data === 'string') {\n    return data.replace(unescapeRegex, match => UNESCAPE_MAP[match]) as any;\n  }\n  return data;\n}\n\n/**\n * 判断一个值是否为“纯粹的对象”（Plain Object）。\n * 数组、null、函数、Date 对象等都会返回 false。\n * @param {*} v - 待检查的值。\n * @returns {boolean} 如果是纯粹的对象则返回 true，否则返回 false。\n */\nexport const isPO = (v: any): v is Record<string, any> => _.isPlainObject(v);\n\n/**\n * 递归地“净化”一个对象，将其中的数组或对象值转换为字符串。\n * 主要用于准备数据以便在某些特定场景下展示或存储。\n * @param {*} v - 待净化的值。\n * @returns {*} 净化后的值。\n */\nexport function sanitizeArrays(v: any): any {\n  if (Array.isArray(v)) {\n    // 如果是数组，则遍历其元素。如果元素是数组或对象，则字符串化它。\n    return v.map(e => (Array.isArray(e) || _.isPlainObject(e) ? JSON.stringify(e) : e));\n  } else if (_.isPlainObject(v)) {\n    // 如果是对象，则递归地对其每个属性值进行净化。\n    const o: { [key: string]: any } = {};\n    for (const k in v) o[k] = sanitizeArrays(v[k]);\n    return o;\n  } else {\n    // 其他类型的值直接返回。\n    return v;\n  }\n}\n\n/**\n * 安全地将一个对象序列化为格式化的 JSON 字符串。\n * 如果序列化失败，不会抛出异常，而是返回一个包含错误信息的字符串。\n * @param {*} o - 待序列化的对象。\n * @returns {string} 成功则返回 JSON 字符串，失败则返回错误提示。\n */\nexport const J = (o: any): string => {\n  try {\n    return JSON.stringify(o, null, 2); // 使用 2 个空格进行缩进，提高可读性。\n  } catch (e: any) {\n    return `<<stringify失败: ${e?.message || e}>>`;\n  }\n};\n\n/**\n * 使用“新数组覆盖旧数组”的策略来深度合并两个对象。\n * 这是 `_.merge` 的一个变体，专门用于处理模板合并等场景，\n * 在这些场景中，我们希望补丁对象中的数组能够完全替换基础对象中的数组，而不是合并它们。\n * @param {*} base - 基础对象。\n * @param {*} patch - 补丁对象。\n * @returns {*} 合并后的新对象。\n */\nexport function mergeReplaceArray(base: any, patch: any): any {\n  // 使用 _.cloneDeep 确保不修改原始对象。\n  return _.mergeWith(_.cloneDeep(base), _.cloneDeep(patch), (a: any, b: any) => {\n    // 自定义合并逻辑：如果任一值为数组，则直接返回补丁值（b），从而实现覆盖。\n    if (Array.isArray(a) || Array.isArray(b)) return b;\n    // 对于非数组类型，返回 undefined 以使用 _.merge 的默认合并行为。\n    return undefined;\n  });\n}\n\n/**\n * 健壮地解析 `EditLog` 的原始数据。\n * `EditLog` 可能以多种格式存在（对象、数组、JSON字符串），此函数旨在统一处理它们。\n * @param {*} raw - 从变量中读取的原始 `EditLog` 数据。\n * @returns {any[]} 解析后的 `EditLog` 数组。如果解析失败或输入无效，则返回一个空数组。\n */\nexport function parseEditLog(raw: any): any[] {\n  if (Array.isArray(raw)) return raw;\n  if (raw && typeof raw === 'object') return [raw]; // 单个对象也视为有效日志\n  if (typeof raw === 'string') {\n    const s = raw.replace(/^\\s*```(?:json)?\\s*|\\s*```\\s*$/g, ''); // 移除代码围栏\n    try {\n      const arr = JSON.parse(s);\n      return Array.isArray(arr) ? arr : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\n/**\n * 智能地从字符串中移除各种风格的注释，同时保留字符串字面量中的内容。\n *\n * **工作原理**:\n * 该函数通过一个小型状态机来逐字解析输入字符串。它维护一个 `inString` 状态，\n * 用于判断当前字符是否位于一个双引号包裹的字符串内部。\n *\n * 1. 当检测到进入或退出一个字符串时（通过非转义的双引号 `\"`），`inString` 状态会翻转。\n * 2. 如果 `inString` 为 `true`，则所有字符都会被无条件地保留。这确保了字符串值（如 URL）中的 `//` 或 `/*` 不会被当作注释处理。\n * 3. 如果 `inString` 为 `false`，函数会检查是否存在注释标记（`//`, `/*`, `<!--`）。\n * 4. 如果找到注释标记，函数会向前扫描直到注释结束，并跳过这部分内容。\n * 5. 如果没有找到注释，则将当前字符追加到结果中。\n *\n * @param str - 待处理的字符串。\n * @returns 移除了注释的字符串。\n */\nfunction stripComments(str: string): string {\n  if (!str) return '';\n\n  let result = '';\n  let inString = false; // 状态：是否在字符串内部\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n\n    // 检查是否进入或退出字符串。忽略转义的双引号 `\\\"`。\n    if (char === '\"' && (i === 0 || str[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，直接追加字符，不进行任何注释检查。\n    if (inString) {\n      result += char;\n      continue;\n    }\n\n    // --- 只有在字符串外部时，才进行注释检查 ---\n    const nextChar = str[i + 1];\n\n    // 检查行注释 `//`\n    if (char === '/' && nextChar === '/') {\n      const endOfLine = str.indexOf('\\n', i + 2);\n      if (endOfLine === -1) {\n        // 如果没有换行符，说明注释直到字符串末尾，直接结束循环。\n        break;\n      }\n      // 保留换行符，并将索引 `i` 快进到行尾。\n      result += '\\n';\n      i = endOfLine;\n      continue;\n    }\n\n    // 检查块注释 `/* ... */`\n    if (char === '/' && nextChar === '*') {\n      const endOfComment = str.indexOf('*/', i + 2);\n      if (endOfComment === -1) {\n        // 未闭合的注释，忽略剩余所有内容。\n        break;\n      }\n      // 将索引 `i` 快进到注释结尾。\n      i = endOfComment + 1;\n      continue;\n    }\n\n    // 检查 HTML 注释 `<!-- ... -->`\n    if (char === '<' && str.substring(i, i + 4) === '<!--') {\n      const endOfComment = str.indexOf('-->', i + 4);\n      if (endOfComment === -1) {\n        // 未闭合的注释。\n        break;\n      }\n      i = endOfComment + 2;\n      continue;\n    }\n\n    // 如果不是注释，则保留该字符。\n    result += char;\n  }\n  return result;\n}\n\n/**\n * 解析一个包含多个串联 JSON 对象的字符串（类似于 JSONL 格式）。\n * 这种格式有时会由 AI 生成。此函数能够逐个提取并解析它们。\n *\n * @param {string} str - 待解析的字符串。\n * @returns {any[]} 解析出的对象数组。\n */\nexport function parseJsonl(str: string): any[] {\n  const objects: any[] = [];\n  if (!str || typeof str !== 'string') {\n    return objects;\n  }\n\n  // 在解析 JSON 之前，必须先安全地移除所有注释。\n  // 不能使用简单的正则表达式（如 `/\\/\\/.*/g`），因为它无法区分代码中的注释和字符串值（如 URL \"https://...\"）中的 `//`，\n  // 会错误地破坏 JSON 字符串的结构。`stripComments` 函数通过状态管理解决了这个问题。\n  const strWithoutComments = stripComments(str);\n  const trimmedStr = strWithoutComments.trim();\n\n  let braceCount = 0; // 花括号平衡计数器\n  let startIndex = -1; // 当前 JSON 对象的起始索引\n  let inString = false; // 标记是否处于双引号字符串内部\n\n  for (let i = 0; i < trimmedStr.length; i++) {\n    const char = trimmedStr[i];\n\n    // 切换 inString 状态，忽略转义的双引号\n    if (char === '\"' && (i === 0 || trimmedStr[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，则跳过所有花括号的逻辑判断\n    if (inString) continue;\n\n    if (char === '{') {\n      if (braceCount === 0) {\n        // 发现一个新 JSON 对象的开始\n        startIndex = i;\n      }\n      braceCount++;\n    } else if (char === '}') {\n      if (braceCount > 0) {\n        braceCount--;\n        if (braceCount === 0 && startIndex !== -1) {\n          // 花括号平衡，一个完整的 JSON 对象被找到\n          const jsonString = trimmedStr.substring(startIndex, i + 1);\n          try {\n            const obj = JSON.parse(jsonString);\n            objects.push(obj);\n          } catch (e: any) {\n            // 如果解析失败，记录错误并继续，不中断整个过程\n            logger.error(`JSONL 解析失败: ${e?.message || e}. 失败的片段: ${jsonString}`, e);\n          }\n          // 重置状态，准备寻找下一个对象\n          startIndex = -1;\n        }\n      }\n    }\n  }\n  return objects;\n}\n","/**\n * @file ERA 变量框架 - 字符串处理模块\n */\n\n'use strict';\n\nimport { Converter } from 'opencc-js';\n\n/**\n * 生成一个指定长度的随机字符串，用作唯一标识符。\n * @returns {string} 一个随机的、由数字和小写字母组成的字符串。\n */\nexport function rnd(): string {\n  return Math.random().toString(36).slice(2, 8);\n}\n\n/**\n * 从字符串中移除 AI 生成的 Markdown 代码块围栏（如 ```json ... ```）。\n * @param {string} s - 待处理的字符串。\n * @returns {string} 移除围栏并修剪首尾空格后的字符串。\n */\nexport function stripCodeFence(s: string): string {\n  if (!s) return s;\n  let t = String(s).trim();\n  t = t.replace(/^\\s*(?:```|~~~)\\[a-zA-Z0-9_-\\]*\\s*\\r?\\n/, '');\n  t = t.replace(/\\r?\\n(?:```|~~~)\\s*$/, '');\n  return t.trim();\n}\n\nexport type TagMatchMode = 'exact' | 'prefix' | 'suffix' | 'contains' | 'any';\n\n/**\n * 辅助函数：根据关键字和模式创建用于匹配标签名的正则表达式。\n * @param {string} [keyword=''] - 标签关键字。\n * @param {TagMatchMode} [mode='exact'] - 匹配模式。\n * @returns {RegExp} 生成的正则表达式。\n */\nexport function createTagRegex(keyword: string = '', mode: TagMatchMode = 'exact'): RegExp {\n  if (mode === 'any' || keyword === '*') {\n    return /([a-zA-Z][a-zA-Z0-9_]*)/;\n  }\n  // 对 keyword 进行转义，防止特殊字符影响正则\n  const escapedKeyword = keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  switch (mode) {\n    case 'exact':\n      return new RegExp(`(${escapedKeyword})`);\n    case 'prefix':\n      return new RegExp(`(${escapedKeyword}[a-zA-Z0-9_]*)`);\n    case 'suffix':\n      return new RegExp(`([a-zA-Z0-9_]*${escapedKeyword})`);\n    case 'contains':\n    default:\n      return new RegExp(`([a-zA-Z0-9_]*${escapedKeyword}[a-zA-Z0-9_]*)`);\n  }\n}\n\n/**\n * 核心函数：从文本尾部开始，使用正则表达式反向查找第一个完整闭合的标签。\n * @param {string} text - 原始文本。\n * @param {RegExp} tagNameRegex - 用于匹配标签名的正则表达式，必须包含一个捕获组。\n * @param {number} [endIndex=text.length] - 开始搜索的位置。\n * @returns {{startIndex: number, endIndex: number, content: string, tagName: string} | null} 包含起止索引、内容和完整标签名的对象，或 null。\n */\nfunction findTagFromEndByRegex(\n  text: string,\n  tagNameRegex: RegExp,\n  endIndex: number = text.length,\n): { startIndex: number; endIndex: number; content: string; tagName: string } | null {\n  const closeTagRegex = new RegExp(`</${tagNameRegex.source}>`, 'g');\n  let lastMatch = null;\n  let currentMatch;\n\n  // 1. 找到最后一个在 endIndex 之前的闭合标签\n  while ((currentMatch = closeTagRegex.exec(text)) !== null) {\n    if (currentMatch.index < endIndex) {\n      lastMatch = currentMatch;\n    } else {\n      break;\n    }\n  }\n\n  if (!lastMatch) {\n    return null;\n  }\n\n  const tagName = lastMatch[1];\n  const closeIndex = lastMatch.index;\n\n  // 2. 用找到的完整标签名，反向查找对应的开标签\n  const openTag = `<${tagName}>`;\n  const openIndex = text.lastIndexOf(openTag, closeIndex);\n\n  if (openIndex === -1) {\n    // 如果找不到匹配的开标签，则从这个闭合标签前继续递归搜索\n    return findTagFromEndByRegex(text, tagNameRegex, closeIndex);\n  }\n\n  return {\n    startIndex: openIndex,\n    endIndex: closeIndex + `</${tagName}>`.length,\n    content: text.substring(openIndex + openTag.length, closeIndex),\n    tagName: tagName,\n  };\n}\n\n/**\n * 从文本中移除指定的 XML 标签及其内容，支持正则匹配。\n * @param {string} text - 原始文本。\n * @param {RegExp} tagNameRegex - 用于匹配要移除的标签名的正则表达式。\n * @returns {string} 移除标签后的文本。\n */\nexport function removeTagsByRegex(text: string, tagNameRegex: RegExp): string {\n  let processedText = text;\n  while (true) {\n    const found = findTagFromEndByRegex(processedText, tagNameRegex);\n    if (!found) {\n      break;\n    }\n    processedText = processedText.slice(0, found.startIndex) + processedText.slice(found.endIndex);\n  }\n  return processedText;\n}\n\n/**\n * 检查字符串中是否包含 XML 风格的标签，支持正则匹配。\n * @param {string} text - 要检查的字符串。\n * @param {RegExp} [tagNameRegex] - 用于匹配标签名的正则表达式。如果未提供，则检查任何标签。\n * @returns {boolean} 如果包含则返回 true，否则返回 false。\n */\nexport function containsXMLTags(text: string, tagNameRegex?: RegExp): boolean {\n  if (!text) {\n    return false;\n  }\n\n  const tagRegex = tagNameRegex ? new RegExp(`</?${tagNameRegex.source}>`) : /<\\/?\\s*[a-zA-Z][a-zA-Z0-9_]*\\s*>/;\n\n  let inSingleQuote = false;\n  let inDoubleQuote = false;\n  let backslashRun = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    const ch = text[i];\n\n    if (ch === '\\\\') {\n      backslashRun += 1;\n      continue;\n    }\n\n    const isEscaped = backslashRun % 2 === 1;\n    backslashRun = 0;\n\n    if (ch === '\"' && !isEscaped && !inSingleQuote) {\n      inDoubleQuote = !inDoubleQuote;\n      continue;\n    }\n\n    if (ch === \"'\" && !isEscaped && !inDoubleQuote) {\n      inSingleQuote = !inSingleQuote;\n      continue;\n    }\n\n    if (ch === '<' && !isEscaped && !inSingleQuote && !inDoubleQuote) {\n      let j = i + 1;\n      let innerSingleQuote = false;\n      let innerDoubleQuote = false;\n      let innerBackslashRun = 0;\n\n      for (; j < text.length; j++) {\n        const innerCh = text[j];\n\n        if (innerCh === '\\\\') {\n          innerBackslashRun += 1;\n          continue;\n        }\n\n        const innerEscaped = innerBackslashRun % 2 === 1;\n        innerBackslashRun = 0;\n\n        if (innerCh === '\"' && !innerEscaped && !innerSingleQuote) {\n          innerDoubleQuote = !innerDoubleQuote;\n          continue;\n        }\n\n        if (innerCh === \"'\" && !innerEscaped && !innerDoubleQuote) {\n          innerSingleQuote = !innerSingleQuote;\n          continue;\n        }\n\n        if (innerCh === '>' && !innerEscaped && !innerSingleQuote && !innerDoubleQuote) {\n          const rawTag = text.slice(i, j + 1);\n          if (tagRegex.test(rawTag)) {\n            return true;\n          }\n          break;\n        }\n      }\n\n      i = j;\n      backslashRun = 0;\n    }\n  }\n\n  return false;\n}\n\n/**\n * 从文本尾部开始，反向提取所有被特定 XML 风格标签包裹的、完整闭合的内容块，支持正则匹配。\n * @param {string} text - 包含标签的原始文本。\n * @param {RegExp} tagNameRegex - 用于匹配要提取的标签名的正则表达式。\n * @returns {string[]} 包含所有提取内容的数组，顺序与在文本中出现的顺序一致。\n */\nexport function extractBlocksByRegex(text: string, tagNameRegex: RegExp): string[] {\n  const blocks: string[] = [];\n  let searchIndex = text.length;\n\n  while (searchIndex > 0) {\n    const found = findTagFromEndByRegex(text, tagNameRegex, searchIndex);\n    if (!found) {\n      break;\n    }\n    blocks.unshift(found.content); // 保持原始顺序\n    searchIndex = found.startIndex;\n  }\n\n  return blocks;\n}\n\n/**\n * 从文本中安全地提取所有有效、闭合的特定标签内容块。\n * 这是推荐使用的主要提取函数。\n *\n * @param {string} text - 包含标签的原始文本。\n * @param {RegExp} targetTagNameRegex - 用于匹配目标标签名的正则表达式。\n * @param {boolean} [toSimplified=false] - 是否将提取的内容转换为简体中文。\n * @returns {string[]} 包含所有有效内容块的数组。\n */\nexport function extractValidBlocks(text: string, targetTagNameRegex: RegExp, toSimplified: boolean = false): string[] {\n  // 1. 预处理：移除所有包含 \"think\" 的标签块\n  const thinkRegex = createTagRegex('think', 'contains');\n  const processedText = removeTagsByRegex(text, thinkRegex);\n\n  // 2. 提取：从尾部开始查找目标 tag，确保标签闭合\n  const extracted = extractBlocksByRegex(processedText, targetTagNameRegex);\n\n  const validBlocks: string[] = [];\n  for (const block of extracted) {\n    // 3. 清理和校验\n    const cleanedBlock = stripCodeFence(block.trim());\n\n    // 校验：如果内部还包含任何XML标签，则丢弃\n    if (containsXMLTags(cleanedBlock)) {\n      continue;\n    }\n\n    if (cleanedBlock) {\n      if (toSimplified) {\n        const simplifiedBlock = traditionalToSimplified(cleanedBlock);\n        validBlocks.push(simplifiedBlock);\n      } else {\n        validBlocks.push(cleanedBlock);\n      }\n    }\n  }\n\n  return validBlocks;\n}\n\n/**\n * 将字符串中的繁体中文字符转换为简体中文。\n * @param {string} text - 待转换的字符串。\n * @returns {string} 转换后的简体中文字符串。\n */\nconst converter = Converter({ from: 'tw', to: 'cn' });\nexport function traditionalToSimplified(text: string): string {\n  return converter(text);\n}\n","/**\n * 解析字符串中的角色和用户宏, 并将其替换为对应的名称。\n * 这是提供给其他模块调用的公共接口。\n * @param text - 包含宏的输入字符串。\n * @returns - 替换宏后的字符串。\n */\nexport function parseCharacterMacros(text: string): string {\n  // 如果文本中不包含宏特征字符串, 直接返回以优化性能\n  if (!text.includes('{{')) {\n    return text;\n  }\n\n  let result = text;\n  // 使用全局不区分大小写的替换\n  result = result.replace(/{{user}}/gi, SillyTavern.name1);\n  result = result.replace(/{{char}}/gi, SillyTavern.name2);\n  return result;\n}\n\n/**\n * 深度遍历数据, 对所有字符串类型的值应用 parseCharacterMacros 宏替换。\n * @param data - 任何类型的数据。\n * @returns - 经过宏替换后的数据。\n */\nexport const deepParseCharacterMacros = (data: any): any => {\n  if (typeof data === 'string') {\n    return parseCharacterMacros(data);\n  }\n  if (Array.isArray(data)) {\n    return data.map(item => deepParseCharacterMacros(item));\n  }\n  if (typeof data === 'object' && data !== null) {\n    return Object.entries(data).reduce(\n      (acc, [key, value]) => {\n        acc[key] = deepParseCharacterMacros(value);\n        return acc;\n      },\n      {} as Record<string, any>,\n    );\n  }\n  return data;\n};\n","/**\n * @file ERA 变量框架 - 消息处理模块\n * @description\n * 该文件提供了一系列用于处理、查询和更新酒馆消息对象的通用辅助函数。\n */\n\n'use strict';\n\nimport { ERA_DATA_REGEX } from './constants';\nimport { escapeEraData, parseJsonl } from './data';\nimport { Logger } from './log';\nimport { createTagRegex, extractValidBlocks } from './string';\nimport { parseCharacterMacros } from './text';\n\nconst log = new Logger();\n\nexport function extractMessageIdFromDetail(detail: any): number | null {\n  if (detail === null || detail === undefined) {\n    log.debug('extractMessageIdFromDetail', 'detail 为空，无法解析 message_id。');\n    return null;\n  }\n\n  if (typeof detail === 'number') {\n    if (Number.isFinite(detail)) {\n      log.debug('extractMessageIdFromDetail', '从 number detail 获取 message_id。', { message_id: detail });\n      return detail;\n    }\n    log.debug('extractMessageIdFromDetail', 'number detail 非有限值，忽略。', { detail });\n    return null;\n  }\n\n  if (typeof detail === 'string') {\n    const parsed = Number(detail);\n    if (Number.isFinite(parsed)) {\n      log.debug('extractMessageIdFromDetail', '从 string detail 解析 message_id。', {\n        raw: detail,\n        message_id: parsed,\n      });\n      return parsed;\n    }\n    log.debug('extractMessageIdFromDetail', 'string detail 无法解析为有效数字，忽略。', { raw: detail });\n    return null;\n  }\n\n  if (Array.isArray(detail) && detail.length > 0) {\n    const parsed = Number(detail[0]);\n    if (Number.isFinite(parsed)) {\n      log.debug('extractMessageIdFromDetail', '从数组 detail[0] 解析 message_id。', {\n        raw: detail[0],\n        message_id: parsed,\n      });\n      return parsed;\n    }\n    log.debug('extractMessageIdFromDetail', '数组 detail[0] 无法解析为有效数字，忽略。', { raw: detail[0] });\n    return null;\n  }\n\n  if (typeof detail === 'object') {\n    if (typeof detail.message_id === 'number') {\n      if (Number.isFinite(detail.message_id)) {\n        log.debug('extractMessageIdFromDetail', '从对象 detail.message_id(number) 获取 message_id。', {\n          message_id: detail.message_id,\n        });\n        return detail.message_id;\n      }\n      log.debug('extractMessageIdFromDetail', '对象 detail.message_id(number) 不是有限值，忽略。', {\n        message_id: detail.message_id,\n      });\n      return null;\n    }\n    if (typeof detail.message_id === 'string') {\n      const parsed = Number(detail.message_id);\n      if (Number.isFinite(parsed)) {\n        log.debug('extractMessageIdFromDetail', '从对象 detail.message_id(string) 解析 message_id。', {\n          raw: detail.message_id,\n          message_id: parsed,\n        });\n        return parsed;\n      }\n      log.debug('extractMessageIdFromDetail', '对象 detail.message_id(string) 无法解析为有效数字，忽略。', {\n        raw: detail.message_id,\n      });\n      return null;\n    }\n    if (Array.isArray(detail.eventArgs) && detail.eventArgs.length > 0) {\n      const parsed = Number(detail.eventArgs[0]);\n      if (Number.isFinite(parsed)) {\n        log.debug('extractMessageIdFromDetail', '从对象 detail.eventArgs[0] 解析 message_id。', {\n          raw: detail.eventArgs[0],\n          message_id: parsed,\n        });\n        return parsed;\n      }\n      log.debug('extractMessageIdFromDetail', '对象 detail.eventArgs[0] 无法解析为有效数字，忽略。', {\n        raw: detail.eventArgs[0],\n      });\n      return null;\n    }\n  }\n\n  log.debug('extractMessageIdFromDetail', '未能从事件 detail 中解析出有效的 message_id。', { detail });\n  return null;\n}\n\n/**\n * @type {EraData} - 定义了存储在 `<era_data>` 块中的元数据结构。\n */\ntype EraData = {\n  'era-message-key': string;\n  'era-message-type': 'user' | 'assistant';\n};\n\n// ==================================================================\n// 消息读取与解析\n// ==================================================================\n\n/**\n * **【获取消息内容】** 从酒馆的消息对象中安全地提取当前激活（被选中）的消息内容字符串。\n * 这个函数是 ERA 中所有消息内容读取的唯一入口，以确保逻辑统一和健壮性。\n * @param {TavernMessage} msg - 酒馆消息对象。\n * @returns {string | null} 当前激活的消息内容；如果无法获取，则返回 null。\n */\nexport function getMessageContent(msg: any): string | null {\n  if (!msg) return null;\n\n  let content: string | null = null;\n\n  // 优先检查 .mes 属性，这是新版酒馆的规范\n  if (typeof msg.mes === 'string') {\n    content = msg.mes;\n  }\n  // 如果没有 .mes，则处理 swipes\n  else if (Array.isArray(msg.swipes)) {\n    const sid = Number(msg.swipe_id ?? 0);\n    content = msg.swipes[sid] || null;\n  }\n  // 最后，作为兼容，检查旧版的 .message 属性\n  else if (typeof msg.message === 'string') {\n    content = msg.message;\n  }\n\n  if (content === null) {\n    return null;\n  }\n\n  // 在返回内容前进行宏替换。\n  // 这样做是因为酒馆自身的宏替换行为不一致：有时（如消息流式生成后）会替换，\n  // 但有时（如聊天记录刚加载时）则不会，这会导致读取到的内容状态混乱。\n  // 因此，我们统一在获取消息时手动执行一次宏替换，以确保数据的一致性。\n  return parseCharacterMacros(content);\n}\n\n/**\n * 从消息内容字符串中解析出 `EraData` 对象。这是一个只读操作。\n * @param {string | null | undefined} messageContent - 消息的内容字符串。\n * @returns {EraData | null} 解析成功则返回 `EraData` 对象，否则返回 null。\n */\nfunction parseEraData(messageContent: string | null | undefined): EraData | null {\n  if (typeof messageContent !== 'string') {\n    return null;\n  }\n  const match = messageContent.match(ERA_DATA_REGEX);\n  if (!match || !match[1]) {\n    return null;\n  }\n  try {\n    // 由于 MK 块内部是自定义的 `{\"key\"=\"value\"}` 格式，不能使用 JSON.parse。\n    // 必须使用正则表达式进行宽松匹配来提取键值。\n    const customFormatBlock = match[1];\n    const keyMatch = customFormatBlock.match(/\"era-message-key\"\\s*=\\s*\"(.*?)\"/);\n    const typeMatch = customFormatBlock.match(/\"era-message-type\"\\s*=\\s*\"(.*?)\"/);\n\n    if (keyMatch?.[1] && typeMatch?.[1]) {\n      const eraData = {\n        'era-message-key': keyMatch[1],\n        'era-message-type': typeMatch[1] as 'user' | 'assistant',\n      };\n      log.debug('parseEraData', '成功解析 EraData', eraData);\n      return eraData;\n    }\n    log.debug('parseEraData', '未能在 EraData 块中找到完整的键值对', { customFormatBlock });\n    return null;\n  } catch (e) {\n    log.warn('parseEraData', '解析 EraData 块时发生异常', e);\n    return null;\n  }\n}\n\n/**\n * **【判断消息类型】** 根据消息内容中的 `era-message-type` 元数据或 `role` 属性判断是否为用户消息。\n * 优先信任注入的元数据。\n * @param {TavernMessage} msg - 酒馆消息对象。\n * @returns {boolean} 如果是用户消息，则返回 true。\n */\nexport function isUserMessage(msg: any): boolean {\n  const content = getMessageContent(msg);\n  const data = parseEraData(content);\n  if (data) {\n    return data['era-message-type'] === 'user';\n  }\n  // 回退到检查 role 属性\n  return msg?.role === 'user';\n}\n\n/**\n * 从后向前查找并返回最后一条 AI 消息。\n * @returns {TavernMessage | null} 找到的 AI 消息对象，如果找不到则返回 null。\n */\nexport function findLastAiMessage(): any | null {\n  const messages = getChatMessages('0-{{lastMessageId}}', { include_swipes: true });\n  if (!messages || messages.length === 0) {\n    log.debug('findLastAiMessage', '聊天记录为空, 未找到任何消息。');\n    return null;\n  }\n\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n    if (!isUserMessage(msg)) {\n      log.debug('findLastAiMessage', `找到最后一条 AI 消息, ID: ${msg.message_id}`);\n      return msg;\n    }\n  }\n\n  log.debug('findLastAiMessage', '未在聊天记录中找到任何 AI 消息。');\n  return null;\n}\n\n/**\n * **【带重试获取消息内容】**\n * 尝试获取指定或最新AI消息的内容，如果初次获取为空，则会进行指定次数和间隔的重试。\n * 这主要用于应对酒馆消息在事件触发后可能存在的更新延迟。\n * @param {TavernMessage | number} [messageOrId] - （可选）酒馆消息对象或消息 ID。如果未提供，则自动查找最新的 AI 消息。\n * @param {number} [retries=3] - 最大重试次数。\n * @param {number} [delay=50] - 每次重试之间的等待时间（毫秒）。\n * @returns {Promise<string | null>} 成功则返回消息内容，重试后仍然失败则返回 null。\n */\nexport async function getMessageContentWithRetry(\n  messageOrId?: any | number,\n  retries: number = 20,\n  delay: number = 50,\n): Promise<string | null> {\n  let msg: any;\n\n  if (messageOrId) {\n    if (typeof messageOrId === 'number') {\n      const messages = getChatMessages(messageOrId, { include_swipes: true });\n      msg = messages ? messages[0] : null;\n    } else {\n      msg = messageOrId;\n    }\n  } else {\n    msg = findLastAiMessage();\n  }\n\n  if (!msg) {\n    log.warn('getMessageContentWithRetry', '找不到有效的消息对象', { messageOrId });\n    return null;\n  }\n\n  for (let i = 0; i < retries; i++) {\n    const content = getMessageContent(msg);\n    if (content) {\n      return content;\n    }\n    log.log('getMessageContentWithRetry', `获取消息内容失败，将在 ${delay}ms 后重试 (第 ${i + 1} 次)`);\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n\n  log.warn('getMessageContentWithRetry', `重试 ${retries} 次后仍无法获取消息内容`, { message_id: msg.message_id });\n  return getMessageContent(msg); // 返回最后一次尝试的结果 (可能为 null)\n}\n\n// ==================================================================\n// 消息写入\n// ==================================================================\n\n/**\n * **【通用】** 更新指定消息的内容。\n * 这个辅助函数封装了处理 `swipes` 和普通 `message` 的逻辑，提供一个统一的写入接口。\n * @param {any} message - 要更新的消息对象。\n * @param {string} newContent - 全新的消息内容。\n * @param {'none' | 'affected' | 'all'} [refresh='none'] - 更新后是否刷新消息。\n */\nexport async function updateMessageContent(\n  message: any,\n  newContent: string,\n  refresh: 'none' | 'affected' | 'all' = 'none',\n) {\n  const oldContent = getMessageContent(message);\n  //log.debug('updateMessageContent', '更新前的消息内容:', oldContent);\n  //log.debug('updateMessageContent', '更新后的消息内容:', newContent);\n\n  const updatePayload: { message_id: number; message?: string; swipes?: string[] } = {\n    message_id: message.message_id,\n  };\n\n  if (Array.isArray(message.swipes)) {\n    const sid = Number(message.swipe_id ?? 0);\n    const newSwipes = [...message.swipes];\n    newSwipes[sid] = newContent;\n    updatePayload.swipes = newSwipes;\n  } else {\n    updatePayload.message = newContent;\n  }\n\n  await setChatMessages([updatePayload], { refresh });\n}\n\n/**\n * 从消息对象中提取、解析并转义所有 ERA 指令块。\n *\n * @param {any} msg - 酒馆消息对象。\n * @param {boolean} [toSimplified=false] - 是否将提取的指令内容转换为简体中文。\n * @returns {{ allInserts: any[], allEdits: any[], allDeletes: any[] }} - 包含已转义指令数据的对象。\n */\nexport function extractAndParseCommands(\n  msg: any,\n  toSimplified: boolean = false,\n): { allInserts: any[]; allEdits: any[]; allDeletes: any[] } {\n  const rawContent = getMessageContent(msg) || '';\n\n  // 1. 从消息内容中解析出所有指令块。\n  const insertBlocks = extractValidBlocks(rawContent, createTagRegex('VariableInsert', 'exact'), toSimplified);\n  const editBlocks = extractValidBlocks(rawContent, createTagRegex('VariableEdit', 'exact'), toSimplified);\n  const deleteBlocks = extractValidBlocks(rawContent, createTagRegex('VariableDelete', 'exact'), toSimplified);\n\n  log.debug('extractAndParseCommands', '拿到的消息指令块', { insertBlocks, editBlocks, deleteBlocks });\n\n  if (!insertBlocks.length && !editBlocks.length && !deleteBlocks.length) {\n    log.debug('extractAndParseCommands', `消息 (ID: ${msg.message_id}) 未检测到变量修改标签。`);\n  }\n\n  const rawInserts = insertBlocks.flatMap((s: string) => parseJsonl(s));\n  const rawEdits = editBlocks.flatMap((s: string) => parseJsonl(s));\n  const rawDeletes = deleteBlocks.flatMap((s: string) => parseJsonl(s));\n  log.debug('extractAndParseCommands', '转为json后的指令块', { rawInserts, rawEdits, rawDeletes });\n  // 在这里对从消息中解析出的原始数据进行转义，确保所有后续处理都使用转义后的数据。\n  const allInserts = escapeEraData(rawInserts);\n  const allEdits = escapeEraData(rawEdits);\n  const allDeletes = escapeEraData(rawDeletes);\n  log.debug('extractAndParseCommands', '原始数据转义后的指令块', { allInserts, allEdits, allDeletes });\n\n  return { allInserts, allEdits, allDeletes };\n}\n","import { getMessageContent } from '../ERA变量框架/utils/message';\r\n\r\n$(() => {\r\n  console.log('日志测试脚本已加载。');\r\n\r\n  // 监听消息滑动事件\r\n  eventOn('message_swiped', async message_id => {\r\n    // if (typeof message_id !== 'number') return;\r\n    // console.log(`[logTest] \"message_swiped\" 事件触发, 消息ID: ${message_id}`);\r\n    // 更新聊天变量\r\n    // updateVariablesWith(\r\n    //   vars => {\r\n    //     const currentCount = _.get(vars, 'swipe_count', 0);\r\n    //     _.set(vars, 'swipe_count', currentCount + 1);\r\n    //     console.log(`[logTest] swipe_count 已更新为: ${currentCount + 1}`);\r\n    //     return vars;\r\n    //   },\r\n    //   { type: 'chat' },\r\n    // );\r\n    // 1. 获取最新消息对象\r\n    // const latestMessage = getChatMessages(-1, { include_swipes: true })?.[0];\r\n    // if (!latestMessage) {\r\n    //   console.error('[logTest] 无法获取最新消息。');\r\n    //   return;\r\n    // }\r\n    // 2. 调用 ensureMkForLatestMessage\r\n    //console.log('[logTest] 调用 ensureMkForLatestMessage...');\r\n    //const { mk, isNewKey } = await ensureMkForLatestMessage(latestMessage);\r\n    //console.log(`[logTest] ensureMkForLatestMessage 完成。MK: ${mk}, 是否是新Key: ${isNewKey}`);\r\n    // 3. 调用 ensurePlaceholder\r\n    //console.log('[logTest] 调用 ensurePlaceholder...');\r\n    //await ensurePlaceholder(message_id);\r\n    //console.log('[logTest] ensurePlaceholder 完成。');\r\n    // 4. 调用 getMessageContentWithRetry\r\n    // console.log('[logTest] 调用 getMessageContentWithRetry...');\r\n    // const content = await getMessageContentWithRetry(message_id);\r\n    // console.log('[logTest] getMessageContentWithRetry 完成。获取到的内容:', content);\r\n    // const allMessages = getChatMessages('0-{{lastMessageId}}', { include_swipes: true });\r\n    // console.debug('[logTest] \"message_swiped\" 事件处理完毕', '全处理结束后快照，所有消息:', allMessages);\r\n  });\r\n\r\n  // 监听新消息接收事件\r\n  eventOn('message_received', async message_id => {\r\n    // 3. 调用 ensurePlaceholder\r\n    console.log('[logTest] 调用 ensurePlaceholder...');\r\n    const chat_message = getChatMessages(message_id, { include_swipes: true })[0];\r\n    console.log('[logTest] 拿到的chat_message...', chat_message);\r\n    const placeholder = '<test>';\r\n    const currentContent = getMessageContent(chat_message);\r\n\r\n    if (currentContent && currentContent.includes(placeholder)) {\r\n      console.debug('消息已包含占位符，无需操作。');\r\n      return;\r\n    }\r\n\r\n    const newMessage = (currentContent || '').trimEnd() + '\\n' + placeholder;\r\n\r\n    try {\r\n      //await updateMessageContent(chat_message, newMessage, 'affected');\r\n      const updatePayload: { message_id: number; message?: string; swipes?: string[] } = {\r\n        message_id: message_id,\r\n      };\r\n\r\n      if (Array.isArray(chat_message.swipes)) {\r\n        const sid = Number(chat_message.swipe_id ?? 0);\r\n        const newSwipes = [...chat_message.swipes];\r\n        newSwipes[sid] = newMessage;\r\n        updatePayload.swipes = newSwipes;\r\n      } else {\r\n        updatePayload.message = newMessage;\r\n      }\r\n      console.log('[logTest] 写入前的message...', updatePayload);\r\n      await setChatMessages([updatePayload], { refresh: 'affected' });\r\n    } catch (error) {\r\n      console.error('更新消息时发生错误。', error);\r\n    }\r\n    console.log('[logTest] ensurePlaceholder 完成。');\r\n  });\r\n});\r\n"],"names":["z","object","boolean","default","string","number","ERA_DATA_TAG","RegExp","_","Vue","scriptSettingsRef","ref","parse","settings","readonly","DEBUG_CONFIG_LS_KEY","enabledPatterns","disabledPatterns","loadDebugConfig","configStr","globalThis","localStorage","getItem","config","JSON","toRegex","p","replace","enabled","map","disabled","e","console","error","updateConfig","newConfig","uniqueConfig","Set","setItem","stringify","log","eraDebug","add","pattern","delete","Array","from","remove","status","clear","logContext","Logger","moduleName","constructor","this","_getModuleNameFromStack","callerLine","Error","stack","split","find","line","includes","match","formatMessage","funcName","message","String","debug","obj","some","re","test","length","formattedMessage","undefined","warn","value","toastr","warning","errorObj","ESCAPE_MAP","invert","Object","keys","escapeRegExp","join","values","to","parseCharacterMacros","text","result","SillyTavern","name1","name2","getMessageContent","msg","content","mes","isArray","swipes","sid","Number","swipe_id","$","eventOn","async","message_id","chat_message","getChatMessages","include_swipes","placeholder","currentContent","newMessage","trimEnd","updatePayload","newSwipes","setChatMessages","refresh"],"sourceRoot":""}