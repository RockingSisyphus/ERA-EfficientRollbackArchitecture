{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/external var \"_\"","src://tavern_helper_template/src/ApiTest/index.ts","src://tavern_helper_template/src/ApiTest/utils.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = _;","/**\n * @file ERA 变量 API 分组测试脚本\n * @description 在酒馆助手脚本菜单中注册三个按钮，分别用于插入、更新和删除测试数据。\n * **使用说明**: 请按顺序点击按钮 (Insert -> Update/Delete) 以确保测试数据存在。\n */\n\nimport { Logger } from './utils';\n\nconst logger = new Logger('ApiTest');\n\n// ==================================================================\n// 测试用例组定义\n// ==================================================================\n\n/**\n * 插入测试组：\n * 建立一个完整的、包含多种数据类型的初始状态。\n */\nconst insertTestSuite = [\n  {\n    description: '1.1. 插入一个包含 user 和 items 的基础对象',\n    event: 'era:insertByObject',\n    data: {\n      testData: {\n        description: 'Initial state for testing',\n        user: { name: 'Tester', level: 1 },\n        items: ['apple', 'banana', 'cherry'],\n        status: 'active',\n      },\n    },\n  },\n  {\n    description: '1.2. 插入 inventory 对象',\n    event: 'era:insertByPath',\n    data: {\n      path: 'testData.inventory',\n      value: { gold: 100, slots: ['sword', 'shield'] },\n    },\n  },\n  {\n    description: '1.3. 插入 user.stats 对象',\n    event: 'era:insertByPath',\n    data: {\n      path: 'testData.user.stats',\n      value: { str: 10, dex: 8, int: 5 },\n    },\n  },\n  {\n    description: '1.4. 插入 metadata 对象',\n    event: 'era:insertByObject',\n    data: {\n      testData: {\n        metadata: { version: '1.0', author: 'Cline' },\n      },\n    },\n  },\n];\n\n/**\n * 更新测试组：\n * 修改由 insertTestSuite 创建的数据。\n */\nconst updateTestSuite = [\n  {\n    description: '2.1. 更新 user.name',\n    event: 'era:updateByPath',\n    data: {\n      path: 'testData.user.name',\n      value: 'Advanced Tester',\n    },\n  },\n  {\n    description: '2.2. 通过对象合并更新 level 和 status',\n    event: 'era:updateByObject',\n    data: {\n      testData: {\n        user: { level: 5 },\n        status: 'idle',\n      },\n    },\n  },\n  {\n    description: '2.3. 直接赋值更新 gold',\n    event: 'era:updateByPath',\n    data: {\n      path: 'testData.inventory.gold',\n      value: 150,\n    },\n  },\n];\n\n/**\n * 删除测试组：\n * 删除由 insertTestSuite 创建的数据。\n */\nconst deleteTestSuite = [\n  {\n    description: '3.1. [ByPath] 删除 items 数组的第一个元素',\n    event: 'era:deleteByPath',\n    data: {\n      path: 'testData.items[0]',\n    },\n  },\n  {\n    description: '3.2. [ByObject] 删除 user.stats 中的 int 属性',\n    event: 'era:deleteByObject',\n    data: {\n      testData: {\n        user: {\n          stats: {\n            int: {}, // 使用空对象表示删除'int'这个键\n          },\n        },\n      },\n    },\n  },\n  {\n    description: '3.3. [ByObject] 删除整个 metadata 对象',\n    event: 'era:deleteByObject',\n    data: {\n      testData: {\n        metadata: {}, // 使用空对象表示删除'metadata'这个键\n      },\n    },\n  },\n  {\n    description: '3.4. [ByPath] 删除整个 inventory 对象',\n    event: 'era:deleteByPath',\n    data: {\n      path: 'testData.inventory',\n    },\n  },\n];\n\n// ==================================================================\n// 事件监听器注册\n// ==================================================================\n$(() => {\n  logger.log('init', 'ERA API 分组测试脚本已加载');\n\n  /**\n   * 辅助函数：执行一个测试套件\n   * @param suite 要执行的测试套件数组\n   * @param delay 每个动作之间的延迟（毫秒）\n   */\n  function runTestSuite(suite: any[], delay = 500) {\n    suite.forEach((testCase, index) => {\n      setTimeout(() => {\n        logger.log('runTestSuite', `[${index + 1}/${suite.length}] ${testCase.description}`);\n        eventEmit(testCase.event, testCase.data);\n      }, index * delay);\n    });\n  }\n\n  // 注册按钮\n  eventOn(getButtonEvent('Run Insert Tests'), () => {\n    runTestSuite(insertTestSuite);\n  });\n\n  eventOn(getButtonEvent('Run Update Tests'), () => {\n    runTestSuite(updateTestSuite);\n  });\n\n  eventOn(getButtonEvent('Run Delete Tests'), () => {\n    runTestSuite(deleteTestSuite);\n  });\n\n  eventOn(getButtonEvent('Get Current Vars'), () => {\n    logger.log('runTestSuite', `[Get Current Vars] Triggering era:getCurrentVars`);\n    eventEmit('era:getCurrentVars');\n  });\n\n  // 监听 ERA 框架的写入完成事件\n  eventOn('era:writeDone', detail => {\n    const { mk, message_id, actions, selectedMks, editLogs, stat, statWithoutMeta, consecutiveProcessingCount } =\n      detail;\n    const funcName = 'onWriteDone';\n\n    // 如果是由 apiWrite 触发的，则跳过，避免循环\n    if (detail?.actions?.apiWrite === true) {\n      logger.log(funcName, '检测到 apiWrite 触发的事件，已跳过。');\n      return;\n    }\n\n    logger.log(\n      funcName,\n      `接收到 era:writeDone 事件 (MK: ${mk}, MsgID: ${message_id}, Actions: ${JSON.stringify(actions)}, Consecutive: ${consecutiveProcessingCount})`,\n    );\n\n    // 使用 logger.debug 输出详细信息，避免在常规日志中刷屏\n    logger.debug(funcName, '--- Event Payload Details ---');\n    logger.debug(funcName, `Message Key (mk): ${mk}`);\n    logger.debug(funcName, `Message ID (message_id): ${message_id}`);\n    logger.debug(funcName, `Consecutive Processing Count: ${consecutiveProcessingCount}`);\n    logger.debug(funcName, `Actions: ${JSON.stringify(actions, null, 2)}`);\n\n    // 对于大型对象，使用 JSON.stringify 配合 logger.debug\n    logger.debug(funcName, `Selected MKs (selectedMks): ${JSON.stringify(selectedMks, null, 2)}`);\n    logger.debug(funcName, `Edit Logs (editLogs): ${JSON.stringify(editLogs, null, 2)}`);\n    logger.debug(funcName, `Stat (with meta): ${JSON.stringify(stat, null, 2)}`);\n    logger.debug(funcName, `Stat (without meta): ${JSON.stringify(statWithoutMeta, null, 2)}`);\n    logger.debug(funcName, '---------------------------');\n  });\n});\n","/**\n * @file ERA 变量框架 - 通用工具模块\n * @description\n * 该文件提供了一系列与业务逻辑无关的、高度可复用的辅助函数和类。\n * 它们是构建整个 ERA 框架的基石，涵盖了日志记录、字符串处理、数据解析、对象操作等基础功能。\n * 将这些通用功能集中在此处，有助于保持其他模块代码的简洁和专注。\n */\n\n'use strict';\n\nimport _ from 'lodash';\n\n// ==================================================================\n// 日志记录\n// ==================================================================\n\n/**\n * @class Logger\n * @description 一个为 ERA 框架设计的、支持日志分级的记录器。\n *\n * **核心功能**:\n * 1. **日志分级**: 提供 `debug`, `log`, `warn`, `error` 四个级别，方便过滤和定位问题。\n * 2. **统一格式**: 所有日志都遵循 `《ERA》「模块名」【函数名】日志内容` 的格式，清晰明了。\n * 3. **控制台输出**: 日志会根据级别使用不同颜色和样式的 `console` 方法输出，便于在浏览器中实时调试。\n * 4. **纯粹的控制台日志**: 日志系统不再向酒馆聊天变量中写入任何数据，避免了性能问题和数据污染。\n */\nexport class Logger {\n  private moduleName: string;\n\n  /**\n   * 创建一个新的 Logger 实例。\n   * @param {string} moduleName - 该 Logger 实例绑定的模块名称。\n   */\n  constructor(moduleName: string) {\n    this.moduleName = moduleName;\n  }\n\n  /**\n   * 格式化日志消息。\n   * @param {string} funcName - 调用日志的函数名。\n   * @param {any} message - 日志内容。\n   * @returns {string} 格式化后的日志字符串。\n   */\n  private formatMessage(funcName: string, message: any): string {\n    return `《ERA-ApiTest》「${this.moduleName}」【${funcName}】${String(message)}`;\n  }\n\n  /**\n   * 记录一条 debug 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  debug(funcName: string, message: any) {\n    console.debug(this.formatMessage(funcName, message));\n  }\n\n  /**\n   * 记录一条 log 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  log(funcName: string, message: any) {\n    console.log(`%c${this.formatMessage(funcName, message)}`, 'color: #3498db;');\n  }\n\n  /**\n   * 记录一条 warn 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  warn(funcName: string, message: any) {\n    console.warn(`%c${this.formatMessage(funcName, message)}`, 'color: #f39c12;');\n  }\n\n  /**\n   * 记录一条 error 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   * @param {any} [errorObj] - 可选的、附加到日志中的错误对象。\n   */\n  error(funcName: string, message: any, errorObj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (errorObj) {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;', errorObj);\n    } else {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;');\n    }\n  }\n}\n\n// ==================================================================\n// 字符串与数据处理\n// ==================================================================\n\n/**\n * 生成一个指定长度的随机字符串，用作唯一标识符。\n * 基于 `Math.random()`，在同一毫秒内也能保证极高的唯一性。\n * @returns {string} 一个随机的、由数字和小写字母组成的字符串。\n */\nexport function rnd(): string {\n  return Math.random().toString(36).slice(2, 8);\n}\n\n/**\n * 判断一个值是否为“纯粹的对象”（Plain Object）。\n * 数组、null、函数、Date 对象等都会返回 false。\n * @param {*} v - 待检查的值。\n * @returns {boolean} 如果是纯粹的对象则返回 true，否则返回 false。\n */\nexport const isPO = (v: any): v is Record<string, any> => _.isPlainObject(v);\n\n/**\n * 从文本中提取所有被特定 XML 风格标签包裹的内容块。\n * 使用非贪婪模式的正则表达式，但不处理嵌套标签。\n * @param {string} text - 包含标签的原始文本。\n * @param {string} tag - 要提取的标签名称（例如 'VariableEdit'）。\n * @returns {string[]} 包含所有提取并清理后（去除代码围栏和首尾空格）的内容块的数组。\n */\nexport function extractBlocks(text: string, tag: string): string[] {\n  const blocks: string[] = [];\n  // 正则表达式: /<tag>([\\s\\S]*?)<\\/tag>/g\n  // - <${tag}>: 匹配开标签。\n  // - ([\\s\\S]*?): 非贪婪地捕获开闭标签之间的所有字符（包括换行符）。\n  // - <\\/${tag}>: 匹配闭标签。\n  // - g: 全局匹配，以找到所有匹配项。\n  const re = new RegExp(`<${tag}>([\\\\s\\\\S]*?)<\\\\/${tag}>`, 'g');\n  let m;\n  while ((m = re.exec(text))) {\n    const rawBody = (m[1] || '').trim();\n    // 在存入前，先剥离AI可能生成的多余代码围栏。\n    const body = stripCodeFence(rawBody);\n    if (body) blocks.push(body);\n  }\n  return blocks;\n}\n\n/**\n * 从字符串中移除 AI 生成的 Markdown 代码块围栏（如 ```json ... ```）。\n * @param {string} s - 待处理的字符串。\n * @returns {string} 移除围栏并修剪首尾空格后的字符串。\n */\nexport function stripCodeFence(s: string): string {\n  if (!s) return s;\n  let t = String(s).trim();\n  // 移除起始围栏，例如 ```json, ```, ~~~\n  t = t.replace(/^\\s*(?:```|~~~)[a-zA-Z0-9_-]*\\s*\\r?\\n/, '');\n  // 移除结束围栏\n  t = t.replace(/\\r?\\n(?:```|~~~)\\s*$/, '');\n  return t.trim();\n}\n\n/**\n * 递归地“净化”一个对象，将其中的数组或对象值转换为字符串。\n * 主要用于准备数据以便在某些特定场景下展示或存储。\n * @param {*} v - 待净化的值。\n * @returns {*} 净化后的值。\n */\nexport function sanitizeArrays(v: any): any {\n  if (Array.isArray(v)) {\n    // 如果是数组，则遍历其元素。如果元素是数组或对象，则字符串化它。\n    return v.map(e => (Array.isArray(e) || _.isPlainObject(e) ? JSON.stringify(e) : e));\n  } else if (_.isPlainObject(v)) {\n    // 如果是对象，则递归地对其每个属性值进行净化。\n    const o: { [key: string]: any } = {};\n    for (const k in v) o[k] = sanitizeArrays(v[k]);\n    return o;\n  } else {\n    // 其他类型的值直接返回。\n    return v;\n  }\n}\n\n/**\n * 安全地将一个对象序列化为格式化的 JSON 字符串。\n * 如果序列化失败，不会抛出异常，而是返回一个包含错误信息的字符串。\n * @param {*} o - 待序列化的对象。\n * @returns {string} 成功则返回 JSON 字符串，失败则返回错误提示。\n */\nexport const J = (o: any): string => {\n  try {\n    return JSON.stringify(o, null, 2); // 使用 2 个空格进行缩进，提高可读性。\n  } catch (e: any) {\n    return `<<stringify失败: ${e?.message || e}>>`;\n  }\n};\n\n// ==================================================================\n// 对象与数据结构操作\n// ==================================================================\n\n/**\n * 使用“新数组覆盖旧数组”的策略来深度合并两个对象。\n * 这是 `_.merge` 的一个变体，专门用于处理模板合并等场景，\n * 在这些场景中，我们希望补丁对象中的数组能够完全替换基础对象中的数组，而不是合并它们。\n * @param {*} base - 基础对象。\n * @param {*} patch - 补丁对象。\n * @returns {*} 合并后的新对象。\n */\nexport function mergeReplaceArray(base: any, patch: any): any {\n  // 使用 _.cloneDeep 确保不修改原始对象。\n  return _.mergeWith(_.cloneDeep(base), _.cloneDeep(patch), (a: any, b: any) => {\n    // 自定义合并逻辑：如果任一值为数组，则直接返回补丁值（b），从而实现覆盖。\n    if (Array.isArray(a) || Array.isArray(b)) return b;\n    // 对于非数组类型，返回 undefined 以使用 _.merge 的默认合并行为。\n    return undefined;\n  });\n}\n\n/**\n * 健壮地解析 `EditLog` 的原始数据。\n * `EditLog` 可能以多种格式存在（对象、数组、JSON字符串），此函数旨在统一处理它们。\n * @param {*} raw - 从变量中读取的原始 `EditLog` 数据。\n * @returns {any[]} 解析后的 `EditLog` 数组。如果解析失败或输入无效，则返回一个空数组。\n */\nexport function parseEditLog(raw: any): any[] {\n  if (Array.isArray(raw)) return raw;\n  if (raw && typeof raw === 'object') return [raw]; // 单个对象也视为有效日志\n  if (typeof raw === 'string') {\n    const s = raw.replace(/^\\s*```(?:json)?\\s*|\\s*```\\s*$/g, ''); // 移除代码围栏\n    try {\n      const arr = JSON.parse(s);\n      return Array.isArray(arr) ? arr : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\n/**\n * 解析一个包含多个串联 JSON 对象的字符串（类似于 JSONL 格式）。\n * 这种格式有时会由 AI 生成。此函数能够逐个提取并解析它们。\n *\n * @param {string} str - 待解析的字符串。\n * @param {Logger} [logger] - 可选的日志记录器实例，用于记录解析错误。\n * @returns {any[]} 解析出的对象数组。\n */\nexport function parseJsonl(str: string, logger?: Logger): any[] {\n  const objects: any[] = [];\n  if (!str || typeof str !== 'string') {\n    return objects;\n  }\n\n  // 在解析前，先移除所有类型的注释，以提高解析的鲁棒性。\n  const strWithoutComments = str\n    .replace(/\\/\\/.*/g, '') // 移除 // 风格的单行注释\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // 移除 /* ... */ 风格的多行注释\n    .replace(/<!--[\\s\\S]*?-->/g, ''); // 移除 <!-- ... --> 风格的 HTML/XML 注释\n  const trimmedStr = strWithoutComments.trim();\n\n  let braceCount = 0; // 花括号平衡计数器\n  let startIndex = -1; // 当前 JSON 对象的起始索引\n  let inString = false; // 标记是否处于双引号字符串内部\n\n  for (let i = 0; i < trimmedStr.length; i++) {\n    const char = trimmedStr[i];\n\n    // 切换 inString 状态，忽略转义的双引号\n    if (char === '\"' && (i === 0 || trimmedStr[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，则跳过所有花括号的逻辑判断\n    if (inString) continue;\n\n    if (char === '{') {\n      if (braceCount === 0) {\n        // 发现一个新 JSON 对象的开始\n        startIndex = i;\n      }\n      braceCount++;\n    } else if (char === '}') {\n      if (braceCount > 0) {\n        braceCount--;\n        if (braceCount === 0 && startIndex !== -1) {\n          // 花括号平衡，一个完整的 JSON 对象被找到\n          const jsonString = trimmedStr.substring(startIndex, i + 1);\n          try {\n            const obj = JSON.parse(jsonString);\n            objects.push(obj);\n          } catch (e: any) {\n            // 如果解析失败，记录错误并继续，不中断整个过程\n            logger?.error('parseJsonl', `JSONL 解析失败: ${e?.message || e}. 失败的片段: ${jsonString}`, e);\n          }\n          // 重置状态，准备寻找下一个对象\n          startIndex = -1;\n        }\n      }\n    }\n  }\n  return objects;\n}\n"],"names":["_","logger","moduleName","constructor","this","formatMessage","funcName","message","String","debug","console","log","warn","error","errorObj","formattedMessage","insertTestSuite","description","event","data","testData","user","name","level","items","status","path","value","gold","slots","str","dex","int","metadata","version","author","updateTestSuite","deleteTestSuite","stats","$","runTestSuite","suite","delay","forEach","testCase","index","setTimeout","length","eventEmit","eventOn","getButtonEvent","detail","mk","message_id","actions","selectedMks","editLogs","stat","statWithoutMeta","consecutiveProcessingCount","apiWrite","JSON","stringify"],"sourceRoot":""}