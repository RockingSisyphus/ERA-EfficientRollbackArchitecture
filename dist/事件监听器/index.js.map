{"version":3,"file":"index.js","mappings":"AAAqCA,EC0B9B,MAAMC,EACHC,WAMR,WAAAC,CAAYD,GACVE,KAAKF,WAAaA,CACpB,CAQQ,aAAAG,CAAcC,EAAkBC,GACtC,MAAO,eAAeH,KAAKF,eAAeI,KAAYE,OAAOD,IAC/D,CAOA,KAAAE,CAAMH,EAAkBC,GACtBG,QAAQD,MAAML,KAAKC,cAAcC,EAAUC,GAC7C,CAOA,GAAAI,CAAIL,EAAkBC,GACpBG,QAAQC,IAAI,KAAKP,KAAKC,cAAcC,EAAUC,KAAY,kBAC5D,CAOA,IAAAK,CAAKN,EAAkBC,GACrBG,QAAQE,KAAK,KAAKR,KAAKC,cAAcC,EAAUC,KAAY,kBAC7D,CAQA,KAAAM,CAAMP,EAAkBC,EAAcO,GACpC,MAAMC,EAAmBX,KAAKC,cAAcC,EAAUC,GAClDO,EACFJ,QAAQG,MAAM,KAAKE,IAAoB,qCAAsCD,GAE7EJ,QAAQG,MAAM,KAAKE,IAAoB,qCAE3C,EC9EF,MAME,MAAMC,EAAS,IAAIf,EAAO,SAO1B,IAAIgB,EAAM,EAGNC,EAAQC,QAAQC,UACpB,MAAMC,EAAWC,IACfJ,EAAQA,EAAMK,KAAKD,GAAME,MAAMC,IAC7BT,EAAOH,MAAM,UAAW,SAASY,GAAGlB,SAAWkB,IAAKA,MAyBlDC,EAAUC,IAEd,MAAMC,EAAU,IAAIC,KAClB,MAAMC,IAAOb,EACPc,EApCSC,aAAeA,YAAYC,IAAMD,YAAYC,MAAQC,KAAKD,MAsCzEZ,EAAQc,UACN,IAAIC,EAAa,KAAKN,WAAYH,MAAcI,EAAEM,QAAUN,EAAEM,QAAQ,GAAKN,IACvEF,EAAKS,OAAS,IAChBF,GAAc,SAASP,EAAKU,IAAIC,GA7B3B,CAACC,IACZ,IACE,OAAOC,KAAKC,UAAUF,EAAG,CAACG,EAAGC,IACR,iBAARA,GAAoBA,EAAIP,OAAS,IAAY,GAAGO,EAAIC,MAAM,EAAG,SAASD,EAAIP,UAClE,mBAARO,EAA2B,aAAaA,EAAIE,MAAQ,eAC3DF,GAA0B,oBAAZG,SAA2BH,aAAeG,QAAgB,aAAaH,EAAII,YACzFJ,GAA6B,iBAAfA,EAAIK,OAA4B,WAAWL,EAAIP,UAC1DO,EAEX,CAAE,MAEA,IACE,OAAOrC,OAAOiC,EAChB,CAAE,MACA,MAAO,kBACT,CACF,GAa2CU,CAAKX,IAAIY,KAAK,UAErDpC,EAAOL,IAAI,UAAWyB,MAG1B,IAEEiB,eAAe1B,EAAWC,EAC5B,CAAE,MAEA0B,QAAQ3B,EAAWC,EACrB,GAII2B,EAAaC,OAAOC,OAAiC,oBAAlBC,eAAiCA,eAAkB,CAAC,GACvFC,EAAaH,OAAOC,OAAiC,oBAAlBG,eAAiCA,eAAkB,CAAC,GAG7FL,EAAWM,QAAQnC,GACnBiC,EAAWE,QAAQnC,GAGnBL,EAAQc,UACNnB,EAAOL,IACL,OACA,kBAAkB4C,EAAWjB,iBAAiBqB,EAAWrB,wBAM9D,EArFD","sources":["src://tavern_helper_template/external var \"_\"","src://tavern_helper_template/src/事件监听器/utils.ts","src://tavern_helper_template/src/事件监听器/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = _;","/**\n * @file ERA 变量框架 - 通用工具模块\n * @description\n * 该文件提供了一系列与业务逻辑无关的、高度可复用的辅助函数和类。\n * 它们是构建整个 ERA 框架的基石，涵盖了日志记录、字符串处理、数据解析、对象操作等基础功能。\n * 将这些通用功能集中在此处，有助于保持其他模块代码的简洁和专注。\n */\n\n'use strict';\n\nimport _ from 'lodash';\n\n// ==================================================================\n// 日志记录\n// ==================================================================\n\n/**\n * @class Logger\n * @description 一个为 ERA 框架设计的、支持日志分级的记录器。\n *\n * **核心功能**:\n * 1. **日志分级**: 提供 `debug`, `log`, `warn`, `error` 四个级别，方便过滤和定位问题。\n * 2. **统一格式**: 所有日志都遵循 `《ERA》「模块名」【函数名】日志内容` 的格式，清晰明了。\n * 3. **控制台输出**: 日志会根据级别使用不同颜色和样式的 `console` 方法输出，便于在浏览器中实时调试。\n * 4. **纯粹的控制台日志**: 日志系统不再向酒馆聊天变量中写入任何数据，避免了性能问题和数据污染。\n */\nexport class Logger {\n  private moduleName: string;\n\n  /**\n   * 创建一个新的 Logger 实例。\n   * @param {string} moduleName - 该 Logger 实例绑定的模块名称。\n   */\n  constructor(moduleName: string) {\n    this.moduleName = moduleName;\n  }\n\n  /**\n   * 格式化日志消息。\n   * @param {string} funcName - 调用日志的函数名。\n   * @param {any} message - 日志内容。\n   * @returns {string} 格式化后的日志字符串。\n   */\n  private formatMessage(funcName: string, message: any): string {\n    return `《ERA-事件监听器》「${this.moduleName}」【${funcName}】${String(message)}`;\n  }\n\n  /**\n   * 记录一条 debug 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  debug(funcName: string, message: any) {\n    console.debug(this.formatMessage(funcName, message));\n  }\n\n  /**\n   * 记录一条 log 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  log(funcName: string, message: any) {\n    console.log(`%c${this.formatMessage(funcName, message)}`, 'color: #3498db;');\n  }\n\n  /**\n   * 记录一条 warn 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  warn(funcName: string, message: any) {\n    console.warn(`%c${this.formatMessage(funcName, message)}`, 'color: #f39c12;');\n  }\n\n  /**\n   * 记录一条 error 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   * @param {any} [errorObj] - 可选的、附加到日志中的错误对象。\n   */\n  error(funcName: string, message: any, errorObj?: any) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (errorObj) {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;', errorObj);\n    } else {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;');\n    }\n  }\n}\n\n// ==================================================================\n// 字符串与数据处理\n// ==================================================================\n\n/**\n * 生成一个指定长度的随机字符串，用作唯一标识符。\n * 基于 `Math.random()`，在同一毫秒内也能保证极高的唯一性。\n * @returns {string} 一个随机的、由数字和小写字母组成的字符串。\n */\nexport function rnd(): string {\n  return Math.random().toString(36).slice(2, 8);\n}\n\n/**\n * 判断一个值是否为“纯粹的对象”（Plain Object）。\n * 数组、null、函数、Date 对象等都会返回 false。\n * @param {*} v - 待检查的值。\n * @returns {boolean} 如果是纯粹的对象则返回 true，否则返回 false。\n */\nexport const isPO = (v: any): v is Record<string, any> => _.isPlainObject(v);\n\n/**\n * 从文本中提取所有被特定 XML 风格标签包裹的内容块。\n * 使用非贪婪模式的正则表达式，但不处理嵌套标签。\n * @param {string} text - 包含标签的原始文本。\n * @param {string} tag - 要提取的标签名称（例如 'VariableEdit'）。\n * @returns {string[]} 包含所有提取并清理后（去除代码围栏和首尾空格）的内容块的数组。\n */\nexport function extractBlocks(text: string, tag: string): string[] {\n  const blocks: string[] = [];\n  // 正则表达式: /<tag>([\\s\\S]*?)<\\/tag>/g\n  // - <${tag}>: 匹配开标签。\n  // - ([\\s\\S]*?): 非贪婪地捕获开闭标签之间的所有字符（包括换行符）。\n  // - <\\/${tag}>: 匹配闭标签。\n  // - g: 全局匹配，以找到所有匹配项。\n  const re = new RegExp(`<${tag}>([\\\\s\\\\S]*?)<\\\\/${tag}>`, 'g');\n  let m;\n  while ((m = re.exec(text))) {\n    const rawBody = (m[1] || '').trim();\n    // 在存入前，先剥离AI可能生成的多余代码围栏。\n    const body = stripCodeFence(rawBody);\n    if (body) blocks.push(body);\n  }\n  return blocks;\n}\n\n/**\n * 从字符串中移除 AI 生成的 Markdown 代码块围栏（如 ```json ... ```）。\n * @param {string} s - 待处理的字符串。\n * @returns {string} 移除围栏并修剪首尾空格后的字符串。\n */\nexport function stripCodeFence(s: string): string {\n  if (!s) return s;\n  let t = String(s).trim();\n  // 移除起始围栏，例如 ```json, ```, ~~~\n  t = t.replace(/^\\s*(?:```|~~~)[a-zA-Z0-9_-]*\\s*\\r?\\n/, '');\n  // 移除结束围栏\n  t = t.replace(/\\r?\\n(?:```|~~~)\\s*$/, '');\n  return t.trim();\n}\n\n/**\n * 递归地“净化”一个对象，将其中的数组或对象值转换为字符串。\n * 主要用于准备数据以便在某些特定场景下展示或存储。\n * @param {*} v - 待净化的值。\n * @returns {*} 净化后的值。\n */\nexport function sanitizeArrays(v: any): any {\n  if (Array.isArray(v)) {\n    // 如果是数组，则遍历其元素。如果元素是数组或对象，则字符串化它。\n    return v.map(e => (Array.isArray(e) || _.isPlainObject(e) ? JSON.stringify(e) : e));\n  } else if (_.isPlainObject(v)) {\n    // 如果是对象，则递归地对其每个属性值进行净化。\n    const o: { [key: string]: any } = {};\n    for (const k in v) o[k] = sanitizeArrays(v[k]);\n    return o;\n  } else {\n    // 其他类型的值直接返回。\n    return v;\n  }\n}\n\n/**\n * 安全地将一个对象序列化为格式化的 JSON 字符串。\n * 如果序列化失败，不会抛出异常，而是返回一个包含错误信息的字符串。\n * @param {*} o - 待序列化的对象。\n * @returns {string} 成功则返回 JSON 字符串，失败则返回错误提示。\n */\nexport const J = (o: any): string => {\n  try {\n    return JSON.stringify(o, null, 2); // 使用 2 个空格进行缩进，提高可读性。\n  } catch (e: any) {\n    return `<<stringify失败: ${e?.message || e}>>`;\n  }\n};\n\n// ==================================================================\n// 对象与数据结构操作\n// ==================================================================\n\n/**\n * 使用“新数组覆盖旧数组”的策略来深度合并两个对象。\n * 这是 `_.merge` 的一个变体，专门用于处理模板合并等场景，\n * 在这些场景中，我们希望补丁对象中的数组能够完全替换基础对象中的数组，而不是合并它们。\n * @param {*} base - 基础对象。\n * @param {*} patch - 补丁对象。\n * @returns {*} 合并后的新对象。\n */\nexport function mergeReplaceArray(base: any, patch: any): any {\n  // 使用 _.cloneDeep 确保不修改原始对象。\n  return _.mergeWith(_.cloneDeep(base), _.cloneDeep(patch), (a: any, b: any) => {\n    // 自定义合并逻辑：如果任一值为数组，则直接返回补丁值（b），从而实现覆盖。\n    if (Array.isArray(a) || Array.isArray(b)) return b;\n    // 对于非数组类型，返回 undefined 以使用 _.merge 的默认合并行为。\n    return undefined;\n  });\n}\n\n/**\n * 健壮地解析 `EditLog` 的原始数据。\n * `EditLog` 可能以多种格式存在（对象、数组、JSON字符串），此函数旨在统一处理它们。\n * @param {*} raw - 从变量中读取的原始 `EditLog` 数据。\n * @returns {any[]} 解析后的 `EditLog` 数组。如果解析失败或输入无效，则返回一个空数组。\n */\nexport function parseEditLog(raw: any): any[] {\n  if (Array.isArray(raw)) return raw;\n  if (raw && typeof raw === 'object') return [raw]; // 单个对象也视为有效日志\n  if (typeof raw === 'string') {\n    const s = raw.replace(/^\\s*```(?:json)?\\s*|\\s*```\\s*$/g, ''); // 移除代码围栏\n    try {\n      const arr = JSON.parse(s);\n      return Array.isArray(arr) ? arr : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\n/**\n * 解析一个包含多个串联 JSON 对象的字符串（类似于 JSONL 格式）。\n * 这种格式有时会由 AI 生成。此函数能够逐个提取并解析它们。\n *\n * @param {string} str - 待解析的字符串。\n * @param {Logger} [logger] - 可选的日志记录器实例，用于记录解析错误。\n * @returns {any[]} 解析出的对象数组。\n */\nexport function parseJsonl(str: string, logger?: Logger): any[] {\n  const objects: any[] = [];\n  if (!str || typeof str !== 'string') {\n    return objects;\n  }\n\n  // 在解析前，先移除所有类型的注释，以提高解析的鲁棒性。\n  const strWithoutComments = str\n    .replace(/\\/\\/.*/g, '') // 移除 // 风格的单行注释\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // 移除 /* ... */ 风格的多行注释\n    .replace(/<!--[\\s\\S]*?-->/g, ''); // 移除 <!-- ... --> 风格的 HTML/XML 注释\n  const trimmedStr = strWithoutComments.trim();\n\n  let braceCount = 0; // 花括号平衡计数器\n  let startIndex = -1; // 当前 JSON 对象的起始索引\n  let inString = false; // 标记是否处于双引号字符串内部\n\n  for (let i = 0; i < trimmedStr.length; i++) {\n    const char = trimmedStr[i];\n\n    // 切换 inString 状态，忽略转义的双引号\n    if (char === '\"' && (i === 0 || trimmedStr[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，则跳过所有花括号的逻辑判断\n    if (inString) continue;\n\n    if (char === '{') {\n      if (braceCount === 0) {\n        // 发现一个新 JSON 对象的开始\n        startIndex = i;\n      }\n      braceCount++;\n    } else if (char === '}') {\n      if (braceCount > 0) {\n        braceCount--;\n        if (braceCount === 0 && startIndex !== -1) {\n          // 花括号平衡，一个完整的 JSON 对象被找到\n          const jsonString = trimmedStr.substring(startIndex, i + 1);\n          try {\n            const obj = JSON.parse(jsonString);\n            objects.push(obj);\n          } catch (e: any) {\n            // 如果解析失败，记录错误并继续，不中断整个过程\n            logger?.error('parseJsonl', `JSONL 解析失败: ${e?.message || e}. 失败的片段: ${jsonString}`, e);\n          }\n          // 重置状态，准备寻找下一个对象\n          startIndex = -1;\n        }\n      }\n    }\n  }\n  return objects;\n}\n","import { Logger } from './utils';\n\n// ===============================\n// 【事件监听 · 全量日志（串行队列版 / 极简）】\n// - 监听 iframe_events + tavern_events 的所有事件\n// - 任何事件触发时，把“事件名 + 参数”送入全局队列\n// - 全局仅一个Promise链顺序消费，保证日志输出顺序 == 事件到达顺序\n// - 日志写入：使用 Logger 输出到控制台\n// ===============================\n(() => {\n  'use strict';\n\n  /* =========================\n   * 初始化\n   * ========================= */\n  const logger = new Logger('事件监听器');\n\n  /* =========================\n   * 通用工具\n   * ========================= */\n  // —— 小工具：单调时钟与序号，便于肉眼校验顺序\n  const now = () => (performance && performance.now ? performance.now() : Date.now());\n  let SEQ = 0;\n\n  // —— 全局串行队列：将任务接到 chain 后面，保证先到先出\n  let chain = Promise.resolve();\n  const enqueue = (task: () => Promise<void>) => {\n    chain = chain.then(task).catch(e => {\n      logger.error('enqueue', `【监听错误】${e?.message || e}`, e);\n    });\n  };\n\n  // —— 安全字符串化（避免循环引用 / 过长文本刷屏）\n  const safe = (v: any): string => {\n    try {\n      return JSON.stringify(v, (k, val) => {\n        if (typeof val === 'string' && val.length > 300) return `${val.slice(0, 300)}…(${val.length})`;\n        if (typeof val === 'function') return `[Function ${val.name || 'anonymous'}]`;\n        if (val && typeof Element !== 'undefined' && val instanceof Element) return `[Element <${val.tagName}>]`;\n        if (val && typeof val.jquery === 'string') return `[jQuery ${val.length}]`;\n        return val;\n      });\n    } catch {\n      // 某些对象 stringify 仍可能失败，退回 toString\n      try {\n        return String(v);\n      } catch {\n        return '[Unserializable]';\n      }\n    }\n  };\n\n  // —— 通用注册器：把某个事件名挂到“串行打印”处理上\n  const attach = (eventName: string) => {\n    // 用固定的 handler 引用防止重复注册无效；并尽量抢到最前（eventMakeFirst）\n    const handler = (...args: any[]) => {\n      const id = ++SEQ;\n      const t = now();\n      // ★ 将“打印这次事件”的动作丢到全局队列，保证严格先后\n      enqueue(async () => {\n        let logMessage = `[#${id}] 触发事件：${eventName} @${t.toFixed ? t.toFixed(3) : t}`;\n        if (args.length > 0) {\n          logMessage += ` | 数据：${args.map(a => safe(a)).join(' | ')}`;\n        }\n        logger.log('handler', logMessage);\n      });\n    };\n    try {\n      // 优先把我们的监听器插到最前，尽早抢到“到达顺序”\n      eventMakeFirst(eventName, handler);\n    } catch {\n      // 某些环境可能没有 eventMakeFirst，就退回普通 on\n      eventOn(eventName, handler);\n    }\n  };\n\n  // —— 收集所有可监听的事件名\n  const iframeList = Object.values((typeof iframe_events !== 'undefined' && iframe_events) || {});\n  const tavernList = Object.values((typeof tavern_events !== 'undefined' && tavern_events) || {});\n\n  // —— 全部挂上\n  iframeList.forEach(attach);\n  tavernList.forEach(attach);\n\n  // —— 启动提示\n  enqueue(async () => {\n    logger.log(\n      'main',\n      `【事件监听就绪】iframe=${iframeList.length}，tavern=${tavernList.length}（统一串行输出，保障顺序）`,\n    );\n  });\n\n  // —— 可选：如不希望刷屏，可对高频事件做采样（例：只记录每50次 STREAM_TOKEN_RECEIVED_INCREMENTALLY）\n  // 使用方法：在上面的 attach 中判断 eventName 并自定义节流逻辑（此处省略，默认全量记录）\n})();\n"],"names":["_","Logger","moduleName","constructor","this","formatMessage","funcName","message","String","debug","console","log","warn","error","errorObj","formattedMessage","logger","SEQ","chain","Promise","resolve","enqueue","task","then","catch","e","attach","eventName","handler","args","id","t","performance","now","Date","async","logMessage","toFixed","length","map","a","v","JSON","stringify","k","val","slice","name","Element","tagName","jquery","safe","join","eventMakeFirst","eventOn","iframeList","Object","values","iframe_events","tavernList","tavern_events","forEach"],"sourceRoot":""}