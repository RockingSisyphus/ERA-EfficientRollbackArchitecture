{"version":3,"file":"index.js","mappings":"AAAqCA,EC0B9B,MAAMC,EACHC,WAMR,WAAAC,CAAYD,GACVE,KAAKF,WAAaA,CACpB,CAQQ,aAAAG,CAAcC,EAAkBC,GACtC,MAAO,eAAeH,KAAKF,eAAeI,KAAYE,OAAOD,IAC/D,CAOA,KAAAE,CAAMH,EAAkBC,KAAiBG,GACvCC,QAAQF,MAAML,KAAKC,cAAcC,EAAUC,MAAaG,EAC1D,CAOA,GAAAE,CAAIN,EAAkBC,KAAiBG,GACrCC,QAAQC,IAAI,KAAKR,KAAKC,cAAcC,EAAUC,KAAY,qBAAsBG,EAClF,CAOA,IAAAG,CAAKP,EAAkBC,KAAiBG,GACtCC,QAAQE,KAAK,KAAKT,KAAKC,cAAcC,EAAUC,KAAY,qBAAsBG,EACnF,CAQA,KAAAI,CAAMR,EAAkBC,KAAiBG,GACvC,MAAMK,EAAmBX,KAAKC,cAAcC,EAAUC,GAClDG,EAAQM,OAAS,EACnBL,QAAQG,MAAM,KAAKC,IAAoB,wCAAyCL,GAEhFC,QAAQG,MAAM,KAAKC,IAAoB,qCAE3C,EC9EF,MAME,MAAME,EAAS,IAAIhB,EAAO,SAO1B,IAAIiB,EAAM,EACNC,EAAQC,QAAQC,UAChBC,GAAmC,EAGvC,MAAMC,EAAWC,IACfL,EAAQA,EAAMM,KAAKD,GAAME,MAAMZ,IAC7BG,EAAOH,MAAM,UAAW,SAASA,GAAOP,SAAWO,IAASA,MAK1Da,EAAUC,IAEd,MAAMC,EAAU,IAAIC,KAClB,MAAMC,IAAOb,EACPc,EAjBSC,aAAeA,YAAYC,IAAMD,YAAYC,MAAQC,KAAKD,MAmBzEX,EAAQa,UACN,MAAMC,EAAa,KAAKN,WAAYH,OAAeI,EAAEM,QAAUN,EAAEM,QAAQ,GAAKN,IACxEO,EAAqB,GAEvBT,EAAKd,OAAS,GAChBuB,EAAYC,KAAK,CAAEC,UAAWX,IAGhC,IACE,GAA4B,oBAAjBY,cAAwE,mBAAjCA,aAAaC,gBAAgC,CAC7F,MAAMC,EACqC,mBAAlCF,aAAaG,iBAAkCH,aAAaG,wBAAqBC,EACpFC,EACqB,iBAAlBH,GAA8BI,OAAOC,SAASL,IAAkBA,GAAiB,EACpF,KAAKA,IACL,sBACAM,EAAeR,aAAaC,gBAAgBI,EAAO,CAAEI,gBAAgB,IAC3EZ,EAAYC,KAAK,CAAEY,eAAgBF,GACrC,MAAY5B,IACVA,GAAmC,EACnCL,EAAOJ,KAAK,UAAW,oCAE3B,CAAE,MAAOC,GACPG,EAAOH,MAAM,UAAW,kBAAkBA,GAAOP,SAAWO,IAASA,EACvE,CAEAG,EAAOL,IAAI,UAAWyB,KAAeE,MAGzC,IAEEc,eAAezB,EAAWC,EAC5B,CAAE,MAEAyB,QAAQ1B,EAAWC,EACrB,GAII0B,EAAaC,OAAOC,OAAiC,oBAAlBC,eAAiCA,eAAkB,CAAC,GACvFC,EAAaH,OAAOC,OAAiC,oBAAlBG,eAAiCA,eAAkB,CAAC,GAG7FL,EAAWM,QAAQlC,GACnBgC,EAAWE,QAAQlC,GAGnBJ,EAAQa,UACNnB,EAAOL,IACL,OACA,kBAAkB2C,EAAWvC,iBAAiB2C,EAAW3C,wBAM9D,EAvFD","sources":["src://tavern_helper_template/external var \"_\"","src://tavern_helper_template/src/事件监听器/utils.ts","src://tavern_helper_template/src/事件监听器/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = _;","/**\n * @file ERA 变量框架 - 通用工具模块\n * @description\n * 该文件提供了一系列与业务逻辑无关的、高度可复用的辅助函数和类。\n * 它们是构建整个 ERA 框架的基石，涵盖了日志记录、字符串处理、数据解析、对象操作等基础功能。\n * 将这些通用功能集中在此处，有助于保持其他模块代码的简洁和专注。\n */\n\n'use strict';\n\nimport _ from 'lodash';\n\n// ==================================================================\n// 日志记录\n// ==================================================================\n\n/**\n * @class Logger\n * @description 一个为 ERA 框架设计的、支持日志分级的记录器。\n *\n * **核心功能**:\n * 1. **日志分级**: 提供 `debug`, `log`, `warn`, `error` 四个级别，方便过滤和定位问题。\n * 2. **统一格式**: 所有日志都遵循 `《ERA》「模块名」【函数名】日志内容` 的格式，清晰明了。\n * 3. **控制台输出**: 日志会根据级别使用不同颜色和样式的 `console` 方法输出，便于在浏览器中实时调试。\n * 4. **纯粹的控制台日志**: 日志系统不再向酒馆聊天变量中写入任何数据，避免了性能问题和数据污染。\n */\nexport class Logger {\n  private moduleName: string;\n\n  /**\n   * 创建一个新的 Logger 实例。\n   * @param {string} moduleName - 该 Logger 实例绑定的模块名称。\n   */\n  constructor(moduleName: string) {\n    this.moduleName = moduleName;\n  }\n\n  /**\n   * 格式化日志消息。\n   * @param {string} funcName - 调用日志的函数名。\n   * @param {any} message - 日志内容。\n   * @returns {string} 格式化后的日志字符串。\n   */\n  private formatMessage(funcName: string, message: any): string {\n    return `《ERA-事件监听器》「${this.moduleName}」【${funcName}】${String(message)}`;\n  }\n\n  /**\n   * 记录一条 debug 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  debug(funcName: string, message: any, ...details: any[]) {\n    console.debug(this.formatMessage(funcName, message), ...details);\n  }\n\n  /**\n   * 记录一条 log 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  log(funcName: string, message: any, ...details: any[]) {\n    console.log(`%c${this.formatMessage(funcName, message)}`, 'color: #3498db;', ...details);\n  }\n\n  /**\n   * 记录一条 warn 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   */\n  warn(funcName: string, message: any, ...details: any[]) {\n    console.warn(`%c${this.formatMessage(funcName, message)}`, 'color: #f39c12;', ...details);\n  }\n\n  /**\n   * 记录一条 error 级别的日志。\n   * @param {string} funcName - 函数名。\n   * @param {any} message - 日志内容。\n   * @param {...any} details - 可选的、附加到日志中的错误对象或上下文。\n   */\n  error(funcName: string, message: any, ...details: any[]) {\n    const formattedMessage = this.formatMessage(funcName, message);\n    if (details.length > 0) {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;', ...details);\n    } else {\n      console.error(`%c${formattedMessage}`, 'color: #e74c3c; font-weight: bold;');\n    }\n  }\n}\n\n// ==================================================================\n// 字符串与数据处理\n// ==================================================================\n\n/**\n * 生成一个指定长度的随机字符串，用作唯一标识符。\n * 基于 `Math.random()`，在同一毫秒内也能保证极高的唯一性。\n * @returns {string} 一个随机的、由数字和小写字母组成的字符串。\n */\nexport function rnd(): string {\n  return Math.random().toString(36).slice(2, 8);\n}\n\n/**\n * 判断一个值是否为“纯粹的对象”（Plain Object）。\n * 数组、null、函数、Date 对象等都会返回 false。\n * @param {*} v - 待检查的值。\n * @returns {boolean} 如果是纯粹的对象则返回 true，否则返回 false。\n */\nexport const isPO = (v: any): v is Record<string, any> => _.isPlainObject(v);\n\n/**\n * 从文本中提取所有被特定 XML 风格标签包裹的内容块。\n * 使用非贪婪模式的正则表达式，但不处理嵌套标签。\n * @param {string} text - 包含标签的原始文本。\n * @param {string} tag - 要提取的标签名称（例如 'VariableEdit'）。\n * @returns {string[]} 包含所有提取并清理后（去除代码围栏和首尾空格）的内容块的数组。\n */\nexport function extractBlocks(text: string, tag: string): string[] {\n  const blocks: string[] = [];\n  // 正则表达式: /<tag>([\\s\\S]*?)<\\/tag>/g\n  // - <${tag}>: 匹配开标签。\n  // - ([\\s\\S]*?): 非贪婪地捕获开闭标签之间的所有字符（包括换行符）。\n  // - <\\/${tag}>: 匹配闭标签。\n  // - g: 全局匹配，以找到所有匹配项。\n  const re = new RegExp(`<${tag}>([\\\\s\\\\S]*?)<\\\\/${tag}>`, 'g');\n  let m;\n  while ((m = re.exec(text))) {\n    const rawBody = (m[1] || '').trim();\n    // 在存入前，先剥离AI可能生成的多余代码围栏。\n    const body = stripCodeFence(rawBody);\n    if (body) blocks.push(body);\n  }\n  return blocks;\n}\n\n/**\n * 从字符串中移除 AI 生成的 Markdown 代码块围栏（如 ```json ... ```）。\n * @param {string} s - 待处理的字符串。\n * @returns {string} 移除围栏并修剪首尾空格后的字符串。\n */\nexport function stripCodeFence(s: string): string {\n  if (!s) return s;\n  let t = String(s).trim();\n  // 移除起始围栏，例如 ```json, ```, ~~~\n  t = t.replace(/^\\s*(?:```|~~~)[a-zA-Z0-9_-]*\\s*\\r?\\n/, '');\n  // 移除结束围栏\n  t = t.replace(/\\r?\\n(?:```|~~~)\\s*$/, '');\n  return t.trim();\n}\n\n/**\n * 递归地“净化”一个对象，将其中的数组或对象值转换为字符串。\n * 主要用于准备数据以便在某些特定场景下展示或存储。\n * @param {*} v - 待净化的值。\n * @returns {*} 净化后的值。\n */\nexport function sanitizeArrays(v: any): any {\n  if (Array.isArray(v)) {\n    // 如果是数组，则遍历其元素。如果元素是数组或对象，则字符串化它。\n    return v.map(e => (Array.isArray(e) || _.isPlainObject(e) ? JSON.stringify(e) : e));\n  } else if (_.isPlainObject(v)) {\n    // 如果是对象，则递归地对其每个属性值进行净化。\n    const o: { [key: string]: any } = {};\n    for (const k in v) o[k] = sanitizeArrays(v[k]);\n    return o;\n  } else {\n    // 其他类型的值直接返回。\n    return v;\n  }\n}\n\n/**\n * 安全地将一个对象序列化为格式化的 JSON 字符串。\n * 如果序列化失败，不会抛出异常，而是返回一个包含错误信息的字符串。\n * @param {*} o - 待序列化的对象。\n * @returns {string} 成功则返回 JSON 字符串，失败则返回错误提示。\n */\nexport const J = (o: any): string => {\n  try {\n    return JSON.stringify(o, null, 2); // 使用 2 个空格进行缩进，提高可读性。\n  } catch (e: any) {\n    return `<<stringify失败: ${e?.message || e}>>`;\n  }\n};\n\n// ==================================================================\n// 对象与数据结构操作\n// ==================================================================\n\n/**\n * 使用“新数组覆盖旧数组”的策略来深度合并两个对象。\n * 这是 `_.merge` 的一个变体，专门用于处理模板合并等场景，\n * 在这些场景中，我们希望补丁对象中的数组能够完全替换基础对象中的数组，而不是合并它们。\n * @param {*} base - 基础对象。\n * @param {*} patch - 补丁对象。\n * @returns {*} 合并后的新对象。\n */\nexport function mergeReplaceArray(base: any, patch: any): any {\n  // 使用 _.cloneDeep 确保不修改原始对象。\n  return _.mergeWith(_.cloneDeep(base), _.cloneDeep(patch), (a: any, b: any) => {\n    // 自定义合并逻辑：如果任一值为数组，则直接返回补丁值（b），从而实现覆盖。\n    if (Array.isArray(a) || Array.isArray(b)) return b;\n    // 对于非数组类型，返回 undefined 以使用 _.merge 的默认合并行为。\n    return undefined;\n  });\n}\n\n/**\n * 健壮地解析 `EditLog` 的原始数据。\n * `EditLog` 可能以多种格式存在（对象、数组、JSON字符串），此函数旨在统一处理它们。\n * @param {*} raw - 从变量中读取的原始 `EditLog` 数据。\n * @returns {any[]} 解析后的 `EditLog` 数组。如果解析失败或输入无效，则返回一个空数组。\n */\nexport function parseEditLog(raw: any): any[] {\n  if (Array.isArray(raw)) return raw;\n  if (raw && typeof raw === 'object') return [raw]; // 单个对象也视为有效日志\n  if (typeof raw === 'string') {\n    const s = raw.replace(/^\\s*```(?:json)?\\s*|\\s*```\\s*$/g, ''); // 移除代码围栏\n    try {\n      const arr = JSON.parse(s);\n      return Array.isArray(arr) ? arr : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\n/**\n * 解析一个包含多个串联 JSON 对象的字符串（类似于 JSONL 格式）。\n * 这种格式有时会由 AI 生成。此函数能够逐个提取并解析它们。\n *\n * @param {string} str - 待解析的字符串。\n * @param {Logger} [logger] - 可选的日志记录器实例，用于记录解析错误。\n * @returns {any[]} 解析出的对象数组。\n */\nexport function parseJsonl(str: string, logger?: Logger): any[] {\n  const objects: any[] = [];\n  if (!str || typeof str !== 'string') {\n    return objects;\n  }\n\n  // 在解析前，先移除所有类型的注释，以提高解析的鲁棒性。\n  const strWithoutComments = str\n    .replace(/\\/\\/.*/g, '') // 移除 // 风格的单行注释\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // 移除 /* ... */ 风格的多行注释\n    .replace(/<!--[\\s\\S]*?-->/g, ''); // 移除 <!-- ... --> 风格的 HTML/XML 注释\n  const trimmedStr = strWithoutComments.trim();\n\n  let braceCount = 0; // 花括号平衡计数器\n  let startIndex = -1; // 当前 JSON 对象的起始索引\n  let inString = false; // 标记是否处于双引号字符串内部\n\n  for (let i = 0; i < trimmedStr.length; i++) {\n    const char = trimmedStr[i];\n\n    // 切换 inString 状态，忽略转义的双引号\n    if (char === '\"' && (i === 0 || trimmedStr[i - 1] !== '\\\\')) {\n      inString = !inString;\n    }\n\n    // 如果在字符串内部，则跳过所有花括号的逻辑判断\n    if (inString) continue;\n\n    if (char === '{') {\n      if (braceCount === 0) {\n        // 发现一个新 JSON 对象的开始\n        startIndex = i;\n      }\n      braceCount++;\n    } else if (char === '}') {\n      if (braceCount > 0) {\n        braceCount--;\n        if (braceCount === 0 && startIndex !== -1) {\n          // 花括号平衡，一个完整的 JSON 对象被找到\n          const jsonString = trimmedStr.substring(startIndex, i + 1);\n          try {\n            const obj = JSON.parse(jsonString);\n            objects.push(obj);\n          } catch (e: any) {\n            // 如果解析失败，记录错误并继续，不中断整个过程\n            logger?.error('parseJsonl', `JSONL 解析失败: ${e?.message || e}. 失败的片段: ${jsonString}`, e);\n          }\n          // 重置状态，准备寻找下一个对象\n          startIndex = -1;\n        }\n      }\n    }\n  }\n  return objects;\n}\n","import { Logger } from './utils';\n\n// ===============================\n// 【事件监听器】全量日志（串行队列版 / 极简）\n// - 监听 iframe_events + tavern_events 的所有事件\n// - 任何事件触发时，把「事件名 + 参数」送入全局队列\n// - 全局仅一个 Promise 链顺序消费，保证日志输出顺序 == 事件到达顺序\n// - 日志写入：使用 Logger 输出到控制台\n// ===============================\n(() => {\n  'use strict';\n\n  /* =========================\n   * 初始化\n   * ========================= */\n  const logger = new Logger('事件监听器');\n\n  /* =========================\n   * 通用工具\n   * ========================= */\n  // ——小工具：单调时钟与序号，便于肉眼校验顺序\n  const now = () => (performance && performance.now ? performance.now() : Date.now());\n  let SEQ = 0;\n  let chain = Promise.resolve();\n  let tavernHelperApiUnavailableWarned = false;\n\n  // ——全局串行队列：将任务接到 chain 后面，保证先到先出\n  const enqueue = (task: () => Promise<void>) => {\n    chain = chain.then(task).catch(error => {\n      logger.error('enqueue', `【监听错误】${error?.message || error}`, error);\n    });\n  };\n\n  // ——通用注册器：把某个事件名挂到“串行打印”处理上\n  const attach = (eventName: string) => {\n    // 用固定的 handler 引用防止重复注册无效；并尽量抢到最前（eventMakeFirst）\n    const handler = (...args: any[]) => {\n      const id = ++SEQ;\n      const t = now();\n      // ——将“打印这次事件”的动作丢到全局队列，保证严格先到先出\n      enqueue(async () => {\n        const logMessage = `[#${id}] 触发事件「${eventName}」 @${t.toFixed ? t.toFixed(3) : t}`;\n        const attachments: any[] = [];\n\n        if (args.length > 0) {\n          attachments.push({ eventArgs: args });\n        }\n\n        try {\n          if (typeof TavernHelper !== 'undefined' && typeof TavernHelper.getChatMessages === 'function') {\n            const lastMessageId =\n              typeof TavernHelper.getLastMessageId === 'function' ? TavernHelper.getLastMessageId() : undefined;\n            const range =\n              typeof lastMessageId === 'number' && Number.isFinite(lastMessageId) && lastMessageId >= 0\n                ? `0-${lastMessageId}`\n                : '0-{{lastMessageId}}';\n            const chatMessages = TavernHelper.getChatMessages(range, { include_swipes: true });\n            attachments.push({ tavernMessages: chatMessages });\n          } else if (!tavernHelperApiUnavailableWarned) {\n            tavernHelperApiUnavailableWarned = true;\n            logger.warn('handler', 'TavernHelper API 不可用，无法获取聊天消息列表。');\n          }\n        } catch (error: any) {\n          logger.error('handler', `获取聊天消息列表时发生错误: ${error?.message || error}`, error);\n        }\n\n        logger.log('handler', logMessage, ...attachments);\n      });\n    };\n    try {\n      // 优先把我们的监听器插到最前，尽早抢到“到达顺序”\n      eventMakeFirst(eventName, handler);\n    } catch {\n      // 某些环境可能没有 eventMakeFirst，就退回普通 on\n      eventOn(eventName, handler);\n    }\n  };\n\n  // ——收集所有可监听的事件名\n  const iframeList = Object.values((typeof iframe_events !== 'undefined' && iframe_events) || {});\n  const tavernList = Object.values((typeof tavern_events !== 'undefined' && tavern_events) || {});\n\n  // ——全部挂上\n  iframeList.forEach(attach);\n  tavernList.forEach(attach);\n\n  // ——启动提示\n  enqueue(async () => {\n    logger.log(\n      'main',\n      `【事件监听就绪】iframe=${iframeList.length}，tavern=${tavernList.length}（统一串行输出，保障顺序）`,\n    );\n  });\n\n  // ——可选：如不希望刷屏，可对高频事件做采样（例：只记录每 50 次 STREAM_TOKEN_RECEIVED_INCREMENTALLY）\n  // 使用方法：在上面的 attach 中判断 eventName 并自定义节流逻辑（此处省略，默认全量记录）\n})();\n"],"names":["_","Logger","moduleName","constructor","this","formatMessage","funcName","message","String","debug","details","console","log","warn","error","formattedMessage","length","logger","SEQ","chain","Promise","resolve","tavernHelperApiUnavailableWarned","enqueue","task","then","catch","attach","eventName","handler","args","id","t","performance","now","Date","async","logMessage","toFixed","attachments","push","eventArgs","TavernHelper","getChatMessages","lastMessageId","getLastMessageId","undefined","range","Number","isFinite","chatMessages","include_swipes","tavernMessages","eventMakeFirst","eventOn","iframeList","Object","values","iframe_events","tavernList","tavern_events","forEach"],"sourceRoot":""}