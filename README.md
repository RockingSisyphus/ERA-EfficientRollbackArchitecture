# ERA 变量框架 (Efficient Rollback Architecture)

> **注意**: 本文档主要介绍 ERA 框架的核心概念和架构。
> - 如需学习如何构建**基础角色卡**，请参阅 [`./doc/构建era角色卡需要阅读和使用的文件`](./doc/构建era角色卡需要阅读和使用的文件) 文件夹中的文档。
> - 如需学习 EJS 模板、API 调用等**进阶用法**，请参阅 [`./doc/进阶角色卡构建需要阅读和使用的文件`](./doc/进阶角色卡构建需要阅读和使用的文件) 文件夹中的文档。

---

ERA (Efficient Rollback Architecture) 变量框架是一款为 **SillyTavern 角色卡作者** 设计的、基于 [酒馆助手 (Tavern Helper)](https://github.com/N0VI028/JS-Slash-Runner) 的高性能、高鲁棒性脚本，旨在提供一个专业级的消息楼层变量管理解决方案。

它通过读取 AI 消息中的变量修改指令来管理聊天变量，并从根本上解决了因 SillyTavern 的消息删除、分支切换（swipe）等操作而导致的变量状态与聊天历史不一致的核心痛点。

## 核心优势

### 1. 高效的中心化状态管理

与传统框架（如 MVU、表格变量系统）在每个消息楼层都存储一份**全量**变量快照不同，ERA 采用了更为高效的中心化设计：

* **单一状态源**：整个聊天过程中的所有变量状态、变更日志 (`EditLogs`) 以及消息追踪链 (`SelectedMks`)，均统一存储在 `chat` 变量中。
* **独立状态消息**：消息楼层本身不存储任何变量数据。唯一与 ERA 相关的是注入在消息内容中的、作为锚点的**消息密钥 (MK)**。

这种设计极大地减少了数据冗余，有效遏制了因聊天楼层增多而导致的聊天文件体积剧烈膨胀的问题，保证了长期使用的性能与流畅性。

### 2. 鲁棒的架构设计

为了彻底规避 SillyTavern 在处理消息 `swipe` 和删除时可能引发的“内容-变量错位”等问题，ERA 采用了独特的锚点机制：

* **变量与内容分离**：所有变量状态均存储在稳定的 `chat` 变量中。
* **内容内置锚点**：唯一的消息身份标识（**消息密钥, MK**）被直接注入到消息的**内容**字符串中。

通过将变量状态与不稳定的消息变量（message variables）解耦，ERA 确保了其追踪体系不受酒馆底层行为的影响，实现了真正的架构级鲁棒性。

### 3. 强大的自愈同步机制

ERA 的核心是一套强大的状态自愈系统，确保变量状态始终与用户所见的聊天历史保持绝对一致。

* **完整追踪链**：框架通过 `SelectedMks` 数组维护了一条与当前聊天记录完全对应的消息密钥链，并通过 `EditLogs` 记录了每一次变量修改的完整历史。
* **“逆序回滚，顺序重算”**：当监听到任何可能破坏数据一致性的操作时（如删除消息、切换分支），同步机制会立即启动。它能精确地将变量状态**回滚**到变更发生前的干净节点，然后根据当前的实际消息历史**重算**后续所有变更。

无论用户删除了哪一个 `swipe`，甚至是聊天记录中间的某条消息，ERA 的变量系统都能实时响应、自动修复。

### 4. AI 友好的指令格式

ERA 接受由 AI 生成的 JSON 格式指令来更新变量。相比于其他自定义格式，JSON 是 AI 模型极为熟悉的结构化数据格式。

* **降低生成压力**：AI 可以更轻松、更稳定地生成格式正确的 JSON，减少了因符号或格式错误导致的解析失败。
* **提升可靠性**：指令的意图清晰，不易产生歧义，保证了变量操作的准确性。

## 专题：解决 SillyTavern 的核心痛点

SillyTavern 在处理消息历史变更时存在一些非直观的“怪异行为”，这是导致传统变量系统频繁出错的根源。ERA 的设计初衷就是为了根治这些问题。

#### 问题 1：内容与变量的错位

当用户删除一条消息的某个 `swipe` 时（例如，删除第2个 `swipe`），SillyTavern 会将后一个 `swipe`（第3个）的**内容**“顶”到当前位置，但该楼层的**消息变量**却仍然是旧的（第2个 `swipe` 的）。这导致了“新内容、旧变量”的状态错乱。

#### 问题 2：孤儿变量与错误继承

被“顶替”的那个 `swipe`（第3个）的消息变量并未被删除，而是游离在聊天数据中，成为“孤儿变量”。当用户再次 `swipe` 时，新生成的消息会错误地**继承**这个孤儿变量，导致状态混乱进一步加剧。

### ERA 的解决方案

ERA 的架构使其对这些问题天然免疫：

1. **免疫错位**：由于 ERA 的所有状态都存储在 `chat` 变量中，它完全不依赖于酒馆的消息变量。它只关心消息**内容**中的消息密钥 (MK)。
2. **自愈同步**：当删除/切换操作发生时，ERA 的同步机制会被触发。它会发现 `SelectedMks` 记录的旧 MK 与当前消息内容中的新 MK 不匹配，于是立即执行“逆序回滚，顺序重算”流程，根据当前**真实可见**的消息内容来重建变量状态，从而完美地自我修复。

## 使用指南 (角色卡作者)

要将 ERA 变量框架集成到您的角色卡中，请遵循以下四个步骤：

1. **导入 ERA 系统**
    在酒馆助手的脚本管理界面中，添加并启用 ERA 框架脚本。

2. **指导 AI 更新变量**
    在您的世界书（World Info）中，添加条目来指导 AI 如何以及何时使用 `<VariableInsert>` 和 `<VariableEdit>` 标签来更新变量。这是让 AI 理解您的游戏机制或故事状态的关键。

3. **初始化变量**
    在角色卡的第一条消息（Greeting Message）中，包含一个 `<VariableInsert>` 块，用于设置所有变量的初始状态。

    *示例：在角色卡问候语中初始化玩家状态*

    ```
    你好，冒险者！在我们开始之前，先来设定你的初始状态吧。
    <VariableInsert>
      {
        "player": {
          "name": "勇者",
          "hp": 100,
          "gold": 10
        },
        "world_state": {
          "day": 1,
          "weather": "sunny"
        }
      }
    </VariableInsert>
    ```

4. **配置内容隐藏**
    为了提供沉浸式体验，您需要隐藏 ERA 的系统文本（指令块和消息密钥）。在角色卡的“正则表达式替换”设置中，添加规则来匹配并移除这些内容，使其对最终用户不可见。

## 指令参考

### 插入新变量: `<VariableInsert>`

此标签用于向聊天变量中添加新的数据。它遵循“非破坏性”原则，**只会写入不存在的路径**，绝不会覆盖任何已有数据。

### 修改现有变量: `<VariableEdit>`

此标签用于修改**已存在**的变量。如果路径不存在，操作将被忽略。它会用新值完全覆盖旧值。

## 宏参考

ERA 提供了一套强大的宏，允许您在发送给 AI 的消息中动态地查询和注入当前的变量状态。

* `{{ERA:path.to.data}}`: 查询并替换为**不含** `$meta` 的纯净数据。
  * *示例*: `当前玩家HP: {{ERA:player.hp}}`
  * `{{ERA:$ALLDATA}}` 将返回整个移除 `$meta` 后的 `stat_data` 对象。
* `{{ERA-withmeta:path.to.data}}`: 查询并替换为**包含** `$meta` 的原始数据。
  * `{{ERA-withmeta:$ALLDATA}}` 将返回完整的 `stat_data` 对象。

> 更多详细信息，请参阅 [**ERA 宏参考文档**](./doc/适合提供给ai的状态栏html开发文档（只包含html状态栏代码书写部分）/ERA_MACRO_DOCUMENT.md)。

## 事件与 API (开发者)

ERA 框架采用**事件驱动架构**与外部脚本进行交互。您不直接调用 ERA 的函数，而是通过酒馆的 `eventEmit` 和 `eventOn` 系统来发送和接收消息，以实现高度解耦和系统稳定性。

### 监听的事件 (外部 -> ERA)

您可以通过 `eventEmit` 发送以下事件来操作变量。所有事件的参数都应放在 `detail` 对象中。

#### 写入类事件

* `era:insertByObject`: 非破坏性地插入一个对象。
* `era:updateByObject`: 修改一个已存在的对象。
* `era:insertByPath`: 在指定路径插入一个值。
* `era:updateByPath`: 修改指定路径的值（支持 `+=` 等运算）。
* `era:deleteByObject`: 根据对象结构删除一个或多个键。
* `era:deleteByPath`: 删除指定路径的键。

#### 查询类事件

所有查询类事件都会触发一个统一的 `era:queryResult` 事件作为响应。

* `era:getCurrentVars`: 请求获取当前最新的变量状态。
* `era:getSnapshotAtMk`: 请求获取指定消息密钥（MK）所在时间点的历史变量快照。
* `era:getSnapshotsBetweenMks`: 请求获取两个消息密钥（MK）之间（包含两者）的所有历史变量快照。
* `era:getSnapshotAtMId`: 请求获取指定**消息 ID** 所在时间点的历史变量快照。
* `era:getSnapshotsBetweenMIds`: 请求获取两个**消息 ID** 之间（包含两者）的所有历史变量快照。

#### 其他事件

* `era:requestWriteDone`: 请求 ERA 框架重新广播上一次的 `era:writeDone` 事件，用于 UI 初始化等场景。

### 广播的事件 (ERA -> 外部)

ERA 在完成操作后会向外广播以下事件：

* `era:writeDone`: **仅在写入/同步操作成功后**广播，用于通知外部脚本**当前**的变量状态已发生改变。
* `era:queryResult`: 作为所有**查询类 API 事件**的统一响应事件。

> 更多详细信息，请参阅 [**ERA 框架 API 接口文档**](./doc/适合提供给ai的状态栏html开发文档（只包含html状态栏代码书写部分）/ERA_API_DOCUMENT.md)。
